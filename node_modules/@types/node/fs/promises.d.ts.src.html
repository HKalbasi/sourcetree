<span class="hljs-comment">/**
 * The `fs/promises` API provides asynchronous file system methods that return
 * promises.
 *
 * The promise APIs use the underlying Node.js threadpool to perform file
 * system operations off the event loop thread. These operations are not
 * synchronized or threadsafe. Care must be taken when performing multiple
 * concurrent modifications on the same file or data corruption may occur.
 * <span class="hljs-doctag">@since</span> v10.0.0
 */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string"><span id="lsif588">&#x27;fs/promises&#x27;</span></span> {
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Abortable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:events&#x27;</span>;
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Stream</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:stream&#x27;</span>;
    <span class="hljs-keyword">import</span> {
        <span class="hljs-title class_">Stats</span>,
        <span class="hljs-title class_">BigIntStats</span>,
        <span class="hljs-title class_">StatOptions</span>,
        <span class="hljs-title class_">Write</span>VResult,
        <span class="hljs-title class_">Read</span>VResult,
        <span class="hljs-title class_">PathLike</span>,
        <span class="hljs-title class_">RmDirOptions</span>,
        <span class="hljs-title class_">RmOptions</span>,
        <span class="hljs-title class_">MakeDirectoryOptions</span>,
        <span class="hljs-title class_">Dirent</span>,
        <span class="hljs-title class_">OpenDirOptions</span>,
        <span class="hljs-title class_">Dir</span>,
        <span class="hljs-title class_">ObjectEncodingOptions</span>,
        <span class="hljs-title class_">BufferEncodingOption</span>,
        <span class="hljs-title class_">OpenMode</span>,
        <span class="hljs-title class_">Mode</span>,
        <span class="hljs-title class_">WatchOptions</span>,
        <span class="hljs-title class_">WatchEventType</span>,
        <span class="hljs-title class_">CopyOptions</span>,
    } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:fs&#x27;</span>;
    <span class="hljs-keyword">interface</span> FileChangeInfo&lt;T <span class="hljs-keyword">extends</span> string | Buffer&gt; {
        <span class="hljs-attr">eventType</span>: <span class="hljs-title class_">WatchEventType</span>;
        <span class="hljs-attr">filename</span>: T;
    }
    <span class="hljs-keyword">interface</span> FlagAndOpenMode {
        mode?: <span class="hljs-title class_">Mode</span> | <span class="hljs-literal">undefined</span>;
        flag?: <span class="hljs-title class_">OpenMode</span> | <span class="hljs-literal">undefined</span>;
    }
    <span class="hljs-keyword">interface</span> FileReadResult&lt;T <span class="hljs-keyword">extends</span> ArrayBufferView&gt; {
        <span class="hljs-attr">bytesRead</span>: <span class="hljs-built_in">number</span>;
        <span class="hljs-attr">buffer</span>: T;
    }
    <span class="hljs-keyword">interface</span> FileReadOptions&lt;T <span class="hljs-keyword">extends</span> ArrayBufferView = Buffer&gt; {
        <span class="hljs-comment">/**
         * <span class="hljs-doctag">@default</span> `Buffer.alloc(0xffff)`
         */</span>
        buffer?: T;
        <span class="hljs-comment">/**
         * <span class="hljs-doctag">@default</span> 0
         */</span>
        offset?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;
        <span class="hljs-comment">/**
         * <span class="hljs-doctag">@default</span> `buffer.byteLength`
         */</span>
        length?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;
        position?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;
    }
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Add `EventEmitter` close</span>
    <span class="hljs-keyword">interface</span> FileHandle {
        <span class="hljs-comment">/**
         * The numeric file descriptor managed by the {FileHandle} object.
         * <span class="hljs-doctag">@since</span> v10.0.0
         */</span>
        <span class="hljs-keyword">readonly</span> <span class="hljs-attr">fd</span>: <span class="hljs-built_in">number</span>;
        <span class="hljs-comment">/**
         * Alias of `filehandle.writeFile()`.
         *
         * When operating on file handles, the mode cannot be changed from what it was set
         * to with `fsPromises.open()`. Therefore, this is equivalent to `filehandle.writeFile()`.
         * <span class="hljs-doctag">@since</span> v10.0.0
         * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
         */</span>
        <span class="hljs-title function_">appendFile</span>(<span class="hljs-attr">data</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>, options?: (<span class="hljs-title class_">ObjectEncodingOptions</span> &amp; <span class="hljs-title class_">FlagAndOpenMode</span>) | <span class="hljs-title class_">BufferEncoding</span> | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
        <span class="hljs-comment">/**
         * Changes the ownership of the file. A wrapper for [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html).
         * <span class="hljs-doctag">@since</span> v10.0.0
         * <span class="hljs-doctag">@param</span> uid The file&#x27;s new owner&#x27;s user id.
         * <span class="hljs-doctag">@param</span> gid The file&#x27;s new group&#x27;s group id.
         * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
         */</span>
        <span class="hljs-title function_">chown</span>(<span class="hljs-attr">uid</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">gid</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
        <span class="hljs-comment">/**
         * Modifies the permissions on the file. See [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html).
         * <span class="hljs-doctag">@since</span> v10.0.0
         * <span class="hljs-doctag">@param</span> mode the file mode bit mask.
         * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
         */</span>
        <span class="hljs-title function_">chmod</span>(<span class="hljs-attr">mode</span>: <span class="hljs-title class_">Mode</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
        <span class="hljs-comment">/**
         * Forces all currently queued I/O operations associated with the file to the
         * operating system&#x27;s synchronized I/O completion state. Refer to the POSIX[`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details.
         *
         * Unlike `filehandle.sync` this method does not flush modified metadata.
         * <span class="hljs-doctag">@since</span> v10.0.0
         * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
         */</span>
        <span class="hljs-title function_">datasync</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
        <span class="hljs-comment">/**
         * Request that all data for the open file descriptor is flushed to the storage
         * device. The specific implementation is operating system and device specific.
         * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail.
         * <span class="hljs-doctag">@since</span> v10.0.0
         * <span class="hljs-doctag">@return</span> Fufills with `undefined` upon success.
         */</span>
        <span class="hljs-title function_">sync</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
        <span class="hljs-comment">/**
         * Reads data from the file and stores that in the given buffer.
         *
         * If the file is not modified concurrently, the end-of-file is reached when the
         * number of bytes read is zero.
         * <span class="hljs-doctag">@since</span> v10.0.0
         * <span class="hljs-doctag">@param</span> buffer A buffer that will be filled with the file data read.
         * <span class="hljs-doctag">@param</span> [offset=0] The location in the buffer at which to start filling.
         * <span class="hljs-doctag">@param</span> [length=buffer.byteLength] The number of bytes to read.
         * <span class="hljs-doctag">@param</span> position The location where to begin reading data from the file. If `null`, data will be read from the current file position, and the position will be updated. If `position` is an
         * integer, the current file position will remain unchanged.
         * <span class="hljs-doctag">@return</span> Fulfills upon success with an object with two properties:
         */</span>
        read&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ArrayBufferView</span>&gt;(<span class="hljs-attr">buffer</span>: T, offset?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>, length?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>, position?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">FileReadResult</span>&lt;T&gt;&gt;;
        read&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ArrayBufferView</span> = <span class="hljs-title class_">Buffer</span>&gt;(options?: <span class="hljs-title class_">FileReadOptions</span>&lt;T&gt;): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">FileReadResult</span>&lt;T&gt;&gt;;
        <span class="hljs-comment">/**
         * Asynchronously reads the entire contents of a file.
         *
         * If `options` is a string, then it specifies the `encoding`.
         *
         * The `FileHandle` has to support reading.
         *
         * If one or more `filehandle.read()` calls are made on a file handle and then a`filehandle.readFile()` call is made, the data will be read from the current
         * position till the end of the file. It doesn&#x27;t always read from the beginning
         * of the file.
         * <span class="hljs-doctag">@since</span> v10.0.0
         * <span class="hljs-doctag">@return</span> Fulfills upon a successful read with the contents of the file. If no encoding is specified (using `options.encoding`), the data is returned as a {Buffer} object. Otherwise, the
         * data will be a string.
         */</span>
        <span class="hljs-title function_">readFile</span>(
            options?: {
                encoding?: <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>;
                flag?: <span class="hljs-title class_">OpenMode</span> | <span class="hljs-literal">undefined</span>;
            } | <span class="hljs-literal">null</span>
        ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Buffer</span>&gt;;
        <span class="hljs-comment">/**
         * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.
         * The `FileHandle` must have been opened for reading.
         * <span class="hljs-doctag">@param</span> options An object that may contain an optional flag.
         * If a flag is not provided, it defaults to `&#x27;r&#x27;`.
         */</span>
        <span class="hljs-title function_">readFile</span>(
            <span class="hljs-attr">options</span>:
                | {
                      <span class="hljs-attr">encoding</span>: <span class="hljs-title class_">BufferEncoding</span>;
                      flag?: <span class="hljs-title class_">OpenMode</span> | <span class="hljs-literal">undefined</span>;
                  }
                | <span class="hljs-title class_">BufferEncoding</span>
        ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;;
        <span class="hljs-comment">/**
         * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.
         * The `FileHandle` must have been opened for reading.
         * <span class="hljs-doctag">@param</span> options An object that may contain an optional flag.
         * If a flag is not provided, it defaults to `&#x27;r&#x27;`.
         */</span>
        <span class="hljs-title function_">readFile</span>(
            options?:
                | (<span class="hljs-title class_">ObjectEncodingOptions</span> &amp; {
                      flag?: <span class="hljs-title class_">OpenMode</span> | <span class="hljs-literal">undefined</span>;
                  })
                | <span class="hljs-title class_">BufferEncoding</span>
                | <span class="hljs-literal">null</span>
        ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-title class_">Buffer</span>&gt;;
        <span class="hljs-comment">/**
         * <span class="hljs-doctag">@since</span> v10.0.0
         * <span class="hljs-doctag">@return</span> Fulfills with an {fs.Stats} for the file.
         */</span>
        <span class="hljs-title function_">stat</span>(
            opts?: <span class="hljs-title class_">StatOptions</span> &amp; {
                bigint?: <span class="hljs-literal">false</span> | <span class="hljs-literal">undefined</span>;
            }
        ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Stats</span>&gt;;
        <span class="hljs-title function_">stat</span>(
            <span class="hljs-attr">opts</span>: <span class="hljs-title class_">StatOptions</span> &amp; {
                <span class="hljs-attr">bigint</span>: <span class="hljs-literal">true</span>;
            }
        ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">BigIntStats</span>&gt;;
        <span class="hljs-title function_">stat</span>(opts?: <span class="hljs-title class_">StatOptions</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Stats</span> | <span class="hljs-title class_">BigIntStats</span>&gt;;
        <span class="hljs-comment">/**
         * Truncates the file.
         *
         * If the file was larger than `len` bytes, only the first `len` bytes will be
         * retained in the file.
         *
         * The following example retains only the first four bytes of the file:
         *
         * ```js
         * import { open } from &#x27;fs/promises&#x27;;
         *
         * let filehandle = null;
         * try {
         *   filehandle = await open(&#x27;temp.txt&#x27;, &#x27;r+&#x27;);
         *   await filehandle.truncate(4);
         * } finally {
         *   await filehandle?.close();
         * }
         * ```
         *
         * If the file previously was shorter than `len` bytes, it is extended, and the
         * extended part is filled with null bytes (`&#x27;\0&#x27;`):
         *
         * If `len` is negative then `0` will be used.
         * <span class="hljs-doctag">@since</span> v10.0.0
         * <span class="hljs-doctag">@param</span> [len=0]
         * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
         */</span>
        <span class="hljs-title function_">truncate</span>(len?: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
        <span class="hljs-comment">/**
         * Change the file system timestamps of the object referenced by the `FileHandle` then resolves the promise with no arguments upon success.
         * <span class="hljs-doctag">@since</span> v10.0.0
         */</span>
        <span class="hljs-title function_">utimes</span>(<span class="hljs-attr">atime</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-title class_">Date</span>, <span class="hljs-attr">mtime</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-title class_">Date</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
        <span class="hljs-comment">/**
         * Asynchronously writes data to a file, replacing the file if it already exists.`data` can be a string, a buffer, or an object with an own `toString` function
         * property. The promise is resolved with no arguments upon success.
         *
         * If `options` is a string, then it specifies the `encoding`.
         *
         * The `FileHandle` has to support writing.
         *
         * It is unsafe to use `filehandle.writeFile()` multiple times on the same file
         * without waiting for the promise to be resolved (or rejected).
         *
         * If one or more `filehandle.write()` calls are made on a file handle and then a`filehandle.writeFile()` call is made, the data will be written from the
         * current position till the end of the file. It doesn&#x27;t always write from the
         * beginning of the file.
         * <span class="hljs-doctag">@since</span> v10.0.0
         */</span>
        <span class="hljs-title function_">writeFile</span>(<span class="hljs-attr">data</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>, options?: (<span class="hljs-title class_">ObjectEncodingOptions</span> &amp; <span class="hljs-title class_">FlagAndOpenMode</span> &amp; <span class="hljs-title class_">Abortable</span>) | <span class="hljs-title class_">BufferEncoding</span> | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
        <span class="hljs-comment">/**
         * Write `buffer` to the file.
         *
         * If `buffer` is a plain object, it must have an own (not inherited) `toString`function property.
         *
         * The promise is resolved with an object containing two properties:
         *
         * It is unsafe to use `filehandle.write()` multiple times on the same file
         * without waiting for the promise to be resolved (or rejected). For this
         * scenario, use `fs.createWriteStream()`.
         *
         * On Linux, positional writes do not work when the file is opened in append mode.
         * The kernel ignores the position argument and always appends the data to
         * the end of the file.
         * <span class="hljs-doctag">@since</span> v10.0.0
         * <span class="hljs-doctag">@param</span> [offset=0] The start position from within `buffer` where the data to write begins.
         * <span class="hljs-doctag">@param</span> [length=buffer.byteLength] The number of bytes from `buffer` to write.
         * <span class="hljs-doctag">@param</span> position The offset from the beginning of the file where the data from `buffer` should be written. If `position` is not a `number`, the data will be written at the current position.
         * See the POSIX pwrite(2) documentation for more detail.
         */</span>
        write&lt;TBuffer <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Uint8Array</span>&gt;(
            <span class="hljs-attr">buffer</span>: TBuffer,
            offset?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>,
            length?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>,
            position?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>
        ): <span class="hljs-title class_">Promise</span>&lt;{
            <span class="hljs-attr">bytesWritten</span>: <span class="hljs-built_in">number</span>;
            <span class="hljs-attr">buffer</span>: TBuffer;
        }&gt;;
        <span class="hljs-title function_">write</span>(
            <span class="hljs-attr">data</span>: <span class="hljs-built_in">string</span>,
            position?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>,
            encoding?: <span class="hljs-title class_">BufferEncoding</span> | <span class="hljs-literal">null</span>
        ): <span class="hljs-title class_">Promise</span>&lt;{
            <span class="hljs-attr">bytesWritten</span>: <span class="hljs-built_in">number</span>;
            <span class="hljs-attr">buffer</span>: <span class="hljs-built_in">string</span>;
        }&gt;;
        <span class="hljs-comment">/**
         * Write an array of [&amp;lt;ArrayBufferView&amp;gt;](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView)s to the file.
         *
         * The promise is resolved with an object containing a two properties:
         *
         * It is unsafe to call `writev()` multiple times on the same file without waiting
         * for the promise to be resolved (or rejected).
         *
         * On Linux, positional writes don&#x27;t work when the file is opened in append mode.
         * The kernel ignores the position argument and always appends the data to
         * the end of the file.
         * <span class="hljs-doctag">@since</span> v12.9.0
         * <span class="hljs-doctag">@param</span> position The offset from the beginning of the file where the data from `buffers` should be written. If `position` is not a `number`, the data will be written at the current
         * position.
         */</span>
        <span class="hljs-title function_">writev</span>(<span class="hljs-attr">buffers</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-title class_">Node</span>JS.<span class="hljs-property">ArrayBufferView</span>&gt;, position?: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Write</span>VResult&gt;;
        <span class="hljs-comment">/**
         * Read from a file and write to an array of [&amp;lt;ArrayBufferView&amp;gt;](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView)s
         * <span class="hljs-doctag">@since</span> v13.13.0, v12.17.0
         * <span class="hljs-doctag">@param</span> position The offset from the beginning of the file where the data should be read from. If `position` is not a `number`, the data will be read from the current position.
         * <span class="hljs-doctag">@return</span> Fulfills upon success an object containing two properties:
         */</span>
        <span class="hljs-title function_">readv</span>(<span class="hljs-attr">buffers</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-title class_">Node</span>JS.<span class="hljs-property">ArrayBufferView</span>&gt;, position?: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Read</span>VResult&gt;;
        <span class="hljs-comment">/**
         * Closes the file handle after waiting for any pending operation on the handle to
         * complete.
         *
         * ```js
         * import { open } from &#x27;fs/promises&#x27;;
         *
         * let filehandle;
         * try {
         *   filehandle = await open(&#x27;thefile.txt&#x27;, &#x27;r&#x27;);
         * } finally {
         *   await filehandle?.close();
         * }
         * ```
         * <span class="hljs-doctag">@since</span> v10.0.0
         * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
         */</span>
        <span class="hljs-title function_">close</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    }
    <span class="hljs-comment">/**
     * Tests a user&#x27;s permissions for the file or directory specified by `path`.
     * The `mode` argument is an optional integer that specifies the accessibility
     * checks to be performed. Check `File access constants` for possible values
     * of `mode`. It is possible to create a mask consisting of the bitwise OR of
     * two or more values (e.g. `fs.constants.W_OK | fs.constants.R_OK`).
     *
     * If the accessibility check is successful, the promise is resolved with no
     * value. If any of the accessibility checks fail, the promise is rejected
     * with an [&amp;lt;Error&amp;gt;](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object. The following example checks if the file`/etc/passwd` can be read and
     * written by the current process.
     *
     * ```js
     * import { access } from &#x27;fs/promises&#x27;;
     * import { constants } from &#x27;fs&#x27;;
     *
     * try {
     *   await access(&#x27;/etc/passwd&#x27;, constants.R_OK | constants.W_OK);
     *   console.log(&#x27;can access&#x27;);
     * } catch {
     *   console.error(&#x27;cannot access&#x27;);
     * }
     * ```
     *
     * Using `fsPromises.access()` to check for the accessibility of a file before
     * calling `fsPromises.open()` is not recommended. Doing so introduces a race
     * condition, since other processes may change the file&#x27;s state between the two
     * calls. Instead, user code should open/read/write the file directly and handle
     * the error raised if the file is not accessible.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@param</span> [mode=fs.constants.F_OK]
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">access</span>(<span class="hljs-params">path: PathLike, mode?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it
     * already exists.
     *
     * No guarantees are made about the atomicity of the copy operation. If an
     * error occurs after the destination file has been opened for writing, an attempt
     * will be made to remove the destination.
     *
     * ```js
     * import { constants } from &#x27;fs&#x27;;
     * import { copyFile } from &#x27;fs/promises&#x27;;
     *
     * try {
     *   await copyFile(&#x27;source.txt&#x27;, &#x27;destination.txt&#x27;);
     *   console.log(&#x27;source.txt was copied to destination.txt&#x27;);
     * } catch {
     *   console.log(&#x27;The file could not be copied&#x27;);
     * }
     *
     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
     * try {
     *   await copyFile(&#x27;source.txt&#x27;, &#x27;destination.txt&#x27;, constants.COPYFILE_EXCL);
     *   console.log(&#x27;source.txt was copied to destination.txt&#x27;);
     * } catch {
     *   console.log(&#x27;The file could not be copied&#x27;);
     * }
     * ```
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@param</span> src source filename to copy
     * <span class="hljs-doctag">@param</span> dest destination filename of the copy operation
     * <span class="hljs-doctag">@param</span> [mode=0] Optional modifiers that specify the behavior of the copy operation. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g.
     * `fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`)
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">copyFile</span>(<span class="hljs-params">src: PathLike, dest: PathLike, mode?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Opens a `FileHandle`.
     *
     * Refer to the POSIX [`open(2)`](http://man7.org/linux/man-pages/man2/open.2.html) documentation for more detail.
     *
     * Some characters (`&lt; &gt; : &quot; / \ | ? *`) are reserved under Windows as documented
     * by [Naming Files, Paths, and Namespaces](https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file). Under NTFS, if the filename contains
     * a colon, Node.js will open a file system stream, as described by[this MSDN page](https://docs.microsoft.com/en-us/windows/desktop/FileIO/using-streams).
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@param</span> [flags=&#x27;r&#x27;] See `support of file system `flags``.
     * <span class="hljs-doctag">@param</span> [mode=0o666] Sets the file mode (permission and sticky bits) if the file is created.
     * <span class="hljs-doctag">@return</span> Fulfills with a {FileHandle} object.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">path: PathLike, flags: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, mode?: Mode</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">FileHandle</span>&gt;;
    <span class="hljs-comment">/**
     * Renames `oldPath` to `newPath`.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">rename</span>(<span class="hljs-params">oldPath: PathLike, newPath: PathLike</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Truncates (shortens or extends the length) of the content at `path` to `len`bytes.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@param</span> [len=0]
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">truncate</span>(<span class="hljs-params">path: PathLike, len?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Removes the directory identified by `path`.
     *
     * Using `fsPromises.rmdir()` on a file (not a directory) results in the
     * promise being rejected with an `ENOENT` error on Windows and an `ENOTDIR`error on POSIX.
     *
     * To get a behavior similar to the `rm -rf` Unix command, use `fsPromises.rm()` with options `{ recursive: true, force: true }`.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">rmdir</span>(<span class="hljs-params">path: PathLike, options?: RmDirOptions</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Removes files and directories (modeled on the standard POSIX `rm` utility).
     * <span class="hljs-doctag">@since</span> v14.14.0
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_"><span id="lsif5491">rm</span></span>(<span class="hljs-params">path: PathLike, options?: RmOptions</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronously creates a directory.
     *
     * The optional `options` argument can be an integer specifying `mode` (permission
     * and sticky bits), or an object with a `mode` property and a `recursive`property indicating whether parent directories should be created. Calling`fsPromises.mkdir()` when `path` is a directory
     * that exists results in a
     * rejection only when `recursive` is false.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Upon success, fulfills with `undefined` if `recursive` is `false`, or the first directory path created if `recursive` is `true`.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_"><span id="lsif548">mkdir</span></span>(<span class="hljs-params">
        path: PathLike,
        options: MakeDirectoryOptions &amp; {
            recursive: <span class="hljs-literal">true</span>;
        }
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronous mkdir(2) - create a directory.
     * <span class="hljs-doctag">@param</span> path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * <span class="hljs-doctag">@param</span> options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_"><span id="lsif552">mkdir</span></span>(<span class="hljs-params">
        path: PathLike,
        options?:
            | Mode
            | (MakeDirectoryOptions &amp; {
                  recursive?: <span class="hljs-literal">false</span> | <span class="hljs-literal">undefined</span>;
              })
            | <span class="hljs-literal">null</span>
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronous mkdir(2) - create a directory.
     * <span class="hljs-doctag">@param</span> path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * <span class="hljs-doctag">@param</span> options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_"><span id="lsif554">mkdir</span></span>(<span class="hljs-params">path: PathLike, options?: Mode | MakeDirectoryOptions | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>&gt;;
    <span class="hljs-comment">/**
     * Reads the contents of a directory.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the filenames. If the `encoding` is set to `&#x27;buffer&#x27;`, the filenames returned
     * will be passed as `Buffer` objects.
     *
     * If `options.withFileTypes` is set to `true`, the resolved array will contain `fs.Dirent` objects.
     *
     * ```js
     * import { readdir } from &#x27;fs/promises&#x27;;
     *
     * try {
     *   const files = await readdir(path);
     *   for (const file of files)
     *     console.log(file);
     * } catch (err) {
     *   console.error(err);
     * }
     * ```
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with an array of the names of the files in the directory excluding `&#x27;.&#x27;` and `&#x27;..&#x27;`.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">readdir</span>(<span class="hljs-params">
        path: PathLike,
        options?:
            | (ObjectEncodingOptions &amp; {
                  withFileTypes?: <span class="hljs-literal">false</span> | <span class="hljs-literal">undefined</span>;
              })
            | BufferEncoding
            | <span class="hljs-literal">null</span>
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>[]&gt;;
    <span class="hljs-comment">/**
     * Asynchronous readdir(3) - read a directory.
     * <span class="hljs-doctag">@param</span> path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * <span class="hljs-doctag">@param</span> options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `&#x27;utf8&#x27;` is used.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">readdir</span>(<span class="hljs-params">
        path: PathLike,
        options:
            | {
                  encoding: <span class="hljs-string">&#x27;buffer&#x27;</span>;
                  withFileTypes?: <span class="hljs-literal">false</span> | <span class="hljs-literal">undefined</span>;
              }
            | <span class="hljs-string">&#x27;buffer&#x27;</span>
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Buffer</span>[]&gt;;
    <span class="hljs-comment">/**
     * Asynchronous readdir(3) - read a directory.
     * <span class="hljs-doctag">@param</span> path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * <span class="hljs-doctag">@param</span> options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `&#x27;utf8&#x27;` is used.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">readdir</span>(<span class="hljs-params">
        path: PathLike,
        options?:
            | (ObjectEncodingOptions &amp; {
                  withFileTypes?: <span class="hljs-literal">false</span> | <span class="hljs-literal">undefined</span>;
              })
            | BufferEncoding
            | <span class="hljs-literal">null</span>
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>[] | <span class="hljs-title class_">Buffer</span>[]&gt;;
    <span class="hljs-comment">/**
     * Asynchronous readdir(3) - read a directory.
     * <span class="hljs-doctag">@param</span> path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * <span class="hljs-doctag">@param</span> options If called with `withFileTypes: true` the result data will be an array of Dirent.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">readdir</span>(<span class="hljs-params">
        path: PathLike,
        options: ObjectEncodingOptions &amp; {
            withFileTypes: <span class="hljs-literal">true</span>;
        }
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Dirent</span>[]&gt;;
    <span class="hljs-comment">/**
     * Reads the contents of the symbolic link referred to by `path`. See the POSIX[`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more detail. The promise is
     * resolved with the`linkString` upon success.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the link path returned. If the `encoding` is set to `&#x27;buffer&#x27;`, the link path
     * returned will be passed as a `Buffer` object.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with the `linkString` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">readlink</span>(<span class="hljs-params">path: PathLike, options?: ObjectEncodingOptions | BufferEncoding | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * <span class="hljs-doctag">@param</span> path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * <span class="hljs-doctag">@param</span> options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `&#x27;utf8&#x27;` is used.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">readlink</span>(<span class="hljs-params">path: PathLike, options: BufferEncodingOption</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Buffer</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * <span class="hljs-doctag">@param</span> path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * <span class="hljs-doctag">@param</span> options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `&#x27;utf8&#x27;` is used.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">readlink</span>(<span class="hljs-params">path: PathLike, options?: ObjectEncodingOptions | <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-title class_">Buffer</span>&gt;;
    <span class="hljs-comment">/**
     * Creates a symbolic link.
     *
     * The `type` argument is only used on Windows platforms and can be one of `&#x27;dir&#x27;`,`&#x27;file&#x27;`, or `&#x27;junction&#x27;`. Windows junction points require the destination path
     * to be absolute. When using `&#x27;junction&#x27;`, the `target` argument will
     * automatically be normalized to absolute path.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@param</span> [type=&#x27;file&#x27;]
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">symlink</span>(<span class="hljs-params">target: PathLike, path: PathLike, <span class="hljs-keyword">type</span>?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Equivalent to `fsPromises.stat()` unless `path` refers to a symbolic link,
     * in which case the link itself is stat-ed, not the file that it refers to.
     * Refer to the POSIX [`lstat(2)`](http://man7.org/linux/man-pages/man2/lstat.2.html) document for more detail.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with the {fs.Stats} object for the given symbolic link `path`.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">lstat</span>(<span class="hljs-params">
        path: PathLike,
        opts?: StatOptions &amp; {
            bigint?: <span class="hljs-literal">false</span> | <span class="hljs-literal">undefined</span>;
        }
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Stats</span>&gt;;
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">lstat</span>(<span class="hljs-params">
        path: PathLike,
        opts: StatOptions &amp; {
            bigint: <span class="hljs-literal">true</span>;
        }
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">BigIntStats</span>&gt;;
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">lstat</span>(<span class="hljs-params">path: PathLike, opts?: StatOptions</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Stats</span> | <span class="hljs-title class_">BigIntStats</span>&gt;;
    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with the {fs.Stats} object for the given `path`.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">stat</span>(<span class="hljs-params">
        path: PathLike,
        opts?: StatOptions &amp; {
            bigint?: <span class="hljs-literal">false</span> | <span class="hljs-literal">undefined</span>;
        }
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Stats</span>&gt;;
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">stat</span>(<span class="hljs-params">
        path: PathLike,
        opts: StatOptions &amp; {
            bigint: <span class="hljs-literal">true</span>;
        }
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">BigIntStats</span>&gt;;
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">stat</span>(<span class="hljs-params">path: PathLike, opts?: StatOptions</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Stats</span> | <span class="hljs-title class_">BigIntStats</span>&gt;;
    <span class="hljs-comment">/**
     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX[`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">link</span>(<span class="hljs-params">existingPath: PathLike, newPath: PathLike</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * If `path` refers to a symbolic link, then the link is removed without affecting
     * the file or directory to which that link refers. If the `path` refers to a file
     * path that is not a symbolic link, the file is deleted. See the POSIX [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html)documentation for more detail.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">unlink</span>(<span class="hljs-params">path: PathLike</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Changes the permissions of a file.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">chmod</span>(<span class="hljs-params">path: PathLike, mode: Mode</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Changes the permissions on a symbolic link.
     *
     * This method is only implemented on macOS.
     * <span class="hljs-doctag">@deprecated</span> Since v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">lchmod</span>(<span class="hljs-params">path: PathLike, mode: Mode</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Changes the ownership on a symbolic link.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">lchown</span>(<span class="hljs-params">path: PathLike, uid: <span class="hljs-built_in">number</span>, gid: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Changes the access and modification times of a file in the same way as `fsPromises.utimes()`, with the difference that if the path refers to a
     * symbolic link, then the link is not dereferenced: instead, the timestamps of
     * the symbolic link itself are changed.
     * <span class="hljs-doctag">@since</span> v14.5.0, v12.19.0
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">lutimes</span>(<span class="hljs-params">path: PathLike, atime: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">Date</span>, mtime: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">Date</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Changes the ownership of a file.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">chown</span>(<span class="hljs-params">path: PathLike, uid: <span class="hljs-built_in">number</span>, gid: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Change the file system timestamps of the object referenced by `path`.
     *
     * The `atime` and `mtime` arguments follow these rules:
     *
     * * Values can be either numbers representing Unix epoch time, `Date`s, or a
     * numeric string like `&#x27;123456789.0&#x27;`.
     * * If the value can not be converted to a number, or is `NaN`, `Infinity` or`-Infinity`, an `Error` will be thrown.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">utimes</span>(<span class="hljs-params">path: PathLike, atime: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">Date</span>, mtime: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">Date</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Determines the actual location of `path` using the same semantics as the`fs.realpath.native()` function.
     *
     * Only paths that can be converted to UTF8 strings are supported.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the path. If the `encoding` is set to `&#x27;buffer&#x27;`, the path returned will be
     * passed as a `Buffer` object.
     *
     * On Linux, when Node.js is linked against musl libc, the procfs file system must
     * be mounted on `/proc` in order for this function to work. Glibc does not have
     * this restriction.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with the resolved path upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">realpath</span>(<span class="hljs-params">path: PathLike, options?: ObjectEncodingOptions | BufferEncoding | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * <span class="hljs-doctag">@param</span> path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * <span class="hljs-doctag">@param</span> options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `&#x27;utf8&#x27;` is used.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">realpath</span>(<span class="hljs-params">path: PathLike, options: BufferEncodingOption</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Buffer</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * <span class="hljs-doctag">@param</span> path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * <span class="hljs-doctag">@param</span> options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `&#x27;utf8&#x27;` is used.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">realpath</span>(<span class="hljs-params">path: PathLike, options?: ObjectEncodingOptions | BufferEncoding | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-title class_">Buffer</span>&gt;;
    <span class="hljs-comment">/**
     * Creates a unique temporary directory. A unique directory name is generated by
     * appending six random characters to the end of the provided `prefix`. Due to
     * platform inconsistencies, avoid trailing `X` characters in `prefix`. Some
     * platforms, notably the BSDs, can return more than six random characters, and
     * replace trailing `X` characters in `prefix` with random characters.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use.
     *
     * ```js
     * import { mkdtemp } from &#x27;fs/promises&#x27;;
     *
     * try {
     *   await mkdtemp(path.join(os.tmpdir(), &#x27;foo-&#x27;));
     * } catch (err) {
     *   console.error(err);
     * }
     * ```
     *
     * The `fsPromises.mkdtemp()` method will append the six randomly selected
     * characters directly to the `prefix` string. For instance, given a directory`/tmp`, if the intention is to create a temporary directory _within_`/tmp`, the`prefix` must end with a trailing
     * platform-specific path separator
     * (`require(&#x27;path&#x27;).sep`).
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@return</span> Fulfills with a string containing the filesystem path of the newly created temporary directory.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mkdtemp</span>(<span class="hljs-params">prefix: <span class="hljs-built_in">string</span>, options?: ObjectEncodingOptions | BufferEncoding | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.
     * <span class="hljs-doctag">@param</span> options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `&#x27;utf8&#x27;` is used.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mkdtemp</span>(<span class="hljs-params">prefix: <span class="hljs-built_in">string</span>, options: BufferEncodingOption</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Buffer</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.
     * <span class="hljs-doctag">@param</span> options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `&#x27;utf8&#x27;` is used.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mkdtemp</span>(<span class="hljs-params">prefix: <span class="hljs-built_in">string</span>, options?: ObjectEncodingOptions | BufferEncoding | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-title class_">Buffer</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronously writes data to a file, replacing the file if it already exists.`data` can be a string, a `Buffer`, or, an object with an own (not inherited)`toString` function property.
     *
     * The `encoding` option is ignored if `data` is a buffer.
     *
     * If `options` is a string, then it specifies the encoding.
     *
     * Any specified `FileHandle` has to support writing.
     *
     * It is unsafe to use `fsPromises.writeFile()` multiple times on the same file
     * without waiting for the promise to be settled.
     *
     * Similarly to `fsPromises.readFile` \- `fsPromises.writeFile` is a convenience
     * method that performs multiple `write` calls internally to write the buffer
     * passed to it. For performance sensitive code consider using `fs.createWriteStream()`.
     *
     * It is possible to use an `AbortSignal` to cancel an `fsPromises.writeFile()`.
     * Cancelation is &quot;best effort&quot;, and some amount of data is likely still
     * to be written.
     *
     * ```js
     * import { writeFile } from &#x27;fs/promises&#x27;;
     * import { Buffer } from &#x27;buffer&#x27;;
     *
     * try {
     *   const controller = new AbortController();
     *   const { signal } = controller;
     *   const data = new Uint8Array(Buffer.from(&#x27;Hello Node.js&#x27;));
     *   const promise = writeFile(&#x27;message.txt&#x27;, data, { signal });
     *
     *   // Abort the request before the promise settles.
     *   controller.abort();
     *
     *   await promise;
     * } catch (err) {
     *   // When a request is aborted - err is an AbortError
     *   console.error(err);
     * }
     * ```
     *
     * Aborting an ongoing request does not abort individual operating
     * system requests but rather the internal buffering `fs.writeFile` performs.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@param</span> file filename or `FileHandle`
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_"><span id="lsif570">writeFile</span></span>(<span class="hljs-params">
        file: PathLike | FileHandle,
        data: <span class="hljs-built_in">string</span> | NodeJS.ArrayBufferView | Iterable&lt;<span class="hljs-built_in">string</span> | NodeJS.ArrayBufferView&gt; | AsyncIterable&lt;<span class="hljs-built_in">string</span> | NodeJS.ArrayBufferView&gt; | Stream,
        options?:
            | (ObjectEncodingOptions &amp; {
                  mode?: Mode | <span class="hljs-literal">undefined</span>;
                  flag?: OpenMode | <span class="hljs-literal">undefined</span>;
              } &amp; Abortable)
            | BufferEncoding
            | <span class="hljs-literal">null</span>
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronously append data to a file, creating the file if it does not yet
     * exist. `data` can be a string or a `Buffer`.
     *
     * If `options` is a string, then it specifies the `encoding`.
     *
     * The `path` may be specified as a `FileHandle` that has been opened
     * for appending (using `fsPromises.open()`).
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@param</span> path filename or {FileHandle}
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">appendFile</span>(<span class="hljs-params">path: PathLike | FileHandle, data: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">Uint8Array</span>, options?: (ObjectEncodingOptions &amp; FlagAndOpenMode) | BufferEncoding | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronously reads the entire contents of a file.
     *
     * If no encoding is specified (using `options.encoding`), the data is returned
     * as a `Buffer` object. Otherwise, the data will be a string.
     *
     * If `options` is a string, then it specifies the encoding.
     *
     * When the `path` is a directory, the behavior of `fsPromises.readFile()` is
     * platform-specific. On macOS, Linux, and Windows, the promise will be rejected
     * with an error. On FreeBSD, a representation of the directory&#x27;s contents will be
     * returned.
     *
     * It is possible to abort an ongoing `readFile` using an `AbortSignal`. If a
     * request is aborted the promise returned is rejected with an `AbortError`:
     *
     * ```js
     * import { readFile } from &#x27;fs/promises&#x27;;
     *
     * try {
     *   const controller = new AbortController();
     *   const { signal } = controller;
     *   const promise = readFile(fileName, { signal });
     *
     *   // Abort the request before the promise settles.
     *   controller.abort();
     *
     *   await promise;
     * } catch (err) {
     *   // When a request is aborted - err is an AbortError
     *   console.error(err);
     * }
     * ```
     *
     * Aborting an ongoing request does not abort individual operating
     * system requests but rather the internal buffering `fs.readFile` performs.
     *
     * Any specified `FileHandle` has to support reading.
     * <span class="hljs-doctag">@since</span> v10.0.0
     * <span class="hljs-doctag">@param</span> path filename or `FileHandle`
     * <span class="hljs-doctag">@return</span> Fulfills with the contents of the file.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_"><span id="lsif1454">readFile</span></span>(<span class="hljs-params">
        path: PathLike | FileHandle,
        options?:
            | ({
                  encoding?: <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>;
                  flag?: OpenMode | <span class="hljs-literal">undefined</span>;
              } &amp; Abortable)
            | <span class="hljs-literal">null</span>
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Buffer</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronously reads the entire contents of a file.
     * <span class="hljs-doctag">@param</span> path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.
     * <span class="hljs-doctag">@param</span> options An object that may contain an optional flag.
     * If a flag is not provided, it defaults to `&#x27;r&#x27;`.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_"><span id="lsif1458">readFile</span></span>(<span class="hljs-params">
        path: PathLike | FileHandle,
        options:
            | ({
                  encoding: BufferEncoding;
                  flag?: OpenMode | <span class="hljs-literal">undefined</span>;
              } &amp; Abortable)
            | BufferEncoding
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronously reads the entire contents of a file.
     * <span class="hljs-doctag">@param</span> path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.
     * <span class="hljs-doctag">@param</span> options An object that may contain an optional flag.
     * If a flag is not provided, it defaults to `&#x27;r&#x27;`.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_"><span id="lsif1460">readFile</span></span>(<span class="hljs-params">
        path: PathLike | FileHandle,
        options?:
            | (ObjectEncodingOptions &amp;
                  Abortable &amp; {
                      flag?: OpenMode | <span class="hljs-literal">undefined</span>;
                  })
            | BufferEncoding
            | <span class="hljs-literal">null</span>
    </span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-title class_">Buffer</span>&gt;;
    <span class="hljs-comment">/**
     * Asynchronously open a directory for iterative scanning. See the POSIX[`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html) documentation for more detail.
     *
     * Creates an `fs.Dir`, which contains all further functions for reading from
     * and cleaning up the directory.
     *
     * The `encoding` option sets the encoding for the `path` while opening the
     * directory and subsequent read operations.
     *
     * Example using async iteration:
     *
     * ```js
     * import { opendir } from &#x27;fs/promises&#x27;;
     *
     * try {
     *   const dir = await opendir(&#x27;./&#x27;);
     *   for await (const dirent of dir)
     *     console.log(dirent.name);
     * } catch (err) {
     *   console.error(err);
     * }
     * ```
     *
     * When using the async iterator, the `fs.Dir` object will be automatically
     * closed after the iterator exits.
     * <span class="hljs-doctag">@since</span> v12.12.0
     * <span class="hljs-doctag">@return</span> Fulfills with an {fs.Dir}.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">opendir</span>(<span class="hljs-params">path: <span class="hljs-built_in">string</span>, options?: OpenDirOptions</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Dir</span>&gt;;
    <span class="hljs-comment">/**
     * Returns an async iterator that watches for changes on `filename`, where `filename`is either a file or a directory.
     *
     * ```js
     * const { watch } = require(&#x27;fs/promises&#x27;);
     *
     * const ac = new AbortController();
     * const { signal } = ac;
     * setTimeout(() =&gt; ac.abort(), 10000);
     *
     * (async () =&gt; {
     *   try {
     *     const watcher = watch(__filename, { signal });
     *     for await (const event of watcher)
     *       console.log(event);
     *   } catch (err) {
     *     if (err.name === &#x27;AbortError&#x27;)
     *       return;
     *     throw err;
     *   }
     * })();
     * ```
     *
     * On most platforms, `&#x27;rename&#x27;` is emitted whenever a filename appears or
     * disappears in the directory.
     *
     * All the `caveats` for `fs.watch()` also apply to `fsPromises.watch()`.
     * <span class="hljs-doctag">@since</span> v15.9.0
     * <span class="hljs-doctag">@return</span> of objects with the properties:
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">watch</span>(<span class="hljs-params">
        filename: PathLike,
        options:
            | (WatchOptions &amp; {
                  encoding: <span class="hljs-string">&#x27;buffer&#x27;</span>;
              })
            | <span class="hljs-string">&#x27;buffer&#x27;</span>
    </span>): <span class="hljs-title class_">AsyncIterable</span>&lt;<span class="hljs-title class_">FileChangeInfo</span>&lt;<span class="hljs-title class_">Buffer</span>&gt;&gt;;
    <span class="hljs-comment">/**
     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
     * <span class="hljs-doctag">@param</span> filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * <span class="hljs-doctag">@param</span> options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
     * If `encoding` is not supplied, the default of `&#x27;utf8&#x27;` is used.
     * If `persistent` is not supplied, the default of `true` is used.
     * If `recursive` is not supplied, the default of `false` is used.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">watch</span>(<span class="hljs-params">filename: PathLike, options?: WatchOptions | BufferEncoding</span>): <span class="hljs-title class_">AsyncIterable</span>&lt;<span class="hljs-title class_">FileChangeInfo</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;;
    <span class="hljs-comment">/**
     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
     * <span class="hljs-doctag">@param</span> filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * <span class="hljs-doctag">@param</span> options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
     * If `encoding` is not supplied, the default of `&#x27;utf8&#x27;` is used.
     * If `persistent` is not supplied, the default of `true` is used.
     * If `recursive` is not supplied, the default of `false` is used.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">watch</span>(<span class="hljs-params">filename: PathLike, options: WatchOptions | <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">AsyncIterable</span>&lt;<span class="hljs-title class_">FileChangeInfo</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; | <span class="hljs-title class_">AsyncIterable</span>&lt;<span class="hljs-title class_">FileChangeInfo</span>&lt;<span class="hljs-title class_">Buffer</span>&gt;&gt;;
    <span class="hljs-comment">/**
     * Asynchronously copies the entire directory structure from `src` to `dest`,
     * including subdirectories and files.
     *
     * When copying a directory to another directory, globs are not supported and
     * behavior is similar to `cp dir1/ dir2/`.
     * <span class="hljs-doctag">@since</span> v16.7.0
     * <span class="hljs-doctag">@experimental</span>
     * <span class="hljs-doctag">@param</span> src source path to copy.
     * <span class="hljs-doctag">@param</span> dest destination path to copy to.
     * <span class="hljs-doctag">@return</span> Fulfills with `undefined` upon success.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">cp</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, destination: <span class="hljs-built_in">string</span>, opts?: CopyOptions</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
}
<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;node:fs/promises&#x27;</span> {
    <span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs/promises&#x27;</span>;
}
