<span class="hljs-comment">/**
 * `Buffer` objects are used to represent a fixed-length sequence of bytes. Many
 * Node.js APIs support `Buffer`s.
 *
 * The `Buffer` class is a subclass of JavaScript&#x27;s [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) class and
 * extends it with methods that cover additional use cases. Node.js APIs accept
 * plain [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)s wherever `Buffer`s are supported as well.
 *
 * While the `Buffer` class is available within the global scope, it is still
 * recommended to explicitly reference it via an import or require statement.
 *
 * ```js
 * import { Buffer } from &#x27;buffer&#x27;;
 *
 * // Creates a zero-filled Buffer of length 10.
 * const buf1 = Buffer.alloc(10);
 *
 * // Creates a Buffer of length 10,
 * // filled with bytes which all have the value `1`.
 * const buf2 = Buffer.alloc(10, 1);
 *
 * // Creates an uninitialized buffer of length 10.
 * // This is faster than calling Buffer.alloc() but the returned
 * // Buffer instance might contain old data that needs to be
 * // overwritten using fill(), write(), or other functions that fill the Buffer&#x27;s
 * // contents.
 * const buf3 = Buffer.allocUnsafe(10);
 *
 * // Creates a Buffer containing the bytes [1, 2, 3].
 * const buf4 = Buffer.from([1, 2, 3]);
 *
 * // Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries
 * // are all truncated using `(value &amp;#x26; 255)` to fit into the range 0–255.
 * const buf5 = Buffer.from([257, 257.5, -255, &#x27;1&#x27;]);
 *
 * // Creates a Buffer containing the UTF-8-encoded bytes for the string &#x27;tést&#x27;:
 * // [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)
 * // [116, 195, 169, 115, 116] (in decimal notation)
 * const buf6 = Buffer.from(&#x27;tést&#x27;);
 *
 * // Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
 * const buf7 = Buffer.from(&#x27;tést&#x27;, &#x27;latin1&#x27;);
 * ```
 * <span class="hljs-doctag">@see</span> [source](https://github.com/nodejs/node/blob/v16.7.0/lib/buffer.js)
 */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;buffer&#x27;</span> {
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">BinaryLike</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:crypto&#x27;</span>;
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">INSPECT_MAX_BYTES</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">kMaxLength</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">kStringMaxLength</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">constants</span>: {
        <span class="hljs-attr">MAX_LENGTH</span>: <span class="hljs-built_in">number</span>;
        <span class="hljs-attr">MAX_STRING_LENGTH</span>: <span class="hljs-built_in">number</span>;
    };
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">TranscodeEncoding</span> = <span class="hljs-string">&#x27;ascii&#x27;</span> | <span class="hljs-string">&#x27;utf8&#x27;</span> | <span class="hljs-string">&#x27;utf16le&#x27;</span> | <span class="hljs-string">&#x27;ucs2&#x27;</span> | <span class="hljs-string">&#x27;latin1&#x27;</span> | <span class="hljs-string">&#x27;binary&#x27;</span>;
    <span class="hljs-comment">/**
     * Re-encodes the given `Buffer` or `Uint8Array` instance from one character
     * encoding to another. Returns a new `Buffer` instance.
     *
     * Throws if the `fromEnc` or `toEnc` specify invalid character encodings or if
     * conversion from `fromEnc` to `toEnc` is not permitted.
     *
     * Encodings supported by `buffer.transcode()` are: `&#x27;ascii&#x27;`, `&#x27;utf8&#x27;`,`&#x27;utf16le&#x27;`, `&#x27;ucs2&#x27;`, `&#x27;latin1&#x27;`, and `&#x27;binary&#x27;`.
     *
     * The transcoding process will use substitution characters if a given byte
     * sequence cannot be adequately represented in the target encoding. For instance:
     *
     * ```js
     * import { Buffer, transcode } from &#x27;buffer&#x27;;
     *
     * const newBuf = transcode(Buffer.from(&#x27;€&#x27;), &#x27;utf8&#x27;, &#x27;ascii&#x27;);
     * console.log(newBuf.toString(&#x27;ascii&#x27;));
     * // Prints: &#x27;?&#x27;
     * ```
     *
     * Because the Euro (`€`) sign is not representable in US-ASCII, it is replaced
     * with `?` in the transcoded `Buffer`.
     * <span class="hljs-doctag">@since</span> v7.1.0
     * <span class="hljs-doctag">@param</span> source A `Buffer` or `Uint8Array` instance.
     * <span class="hljs-doctag">@param</span> fromEnc The current encoding.
     * <span class="hljs-doctag">@param</span> toEnc To target encoding.
     */</span>
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">transcode</span>(<span class="hljs-params">source: <span class="hljs-built_in">Uint8Array</span>, fromEnc: TranscodeEncoding, toEnc: TranscodeEncoding</span>): <span class="hljs-title class_">Buffer</span>;
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SlowBuffer</span>: {
        <span class="hljs-comment">/** <span class="hljs-doctag">@deprecated</span> since v6.0.0, use `Buffer.allocUnsafeSlow()` */</span>
        <span class="hljs-keyword">new</span> (<span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Buffer</span>;
        <span class="hljs-attr">prototype</span>: <span class="hljs-title class_">Buffer</span>;
    };
    <span class="hljs-comment">/**
     * Resolves a `&#x27;blob:nodedata:...&#x27;` an associated `Blob` object registered using
     * a prior call to `URL.createObjectURL()`.
     * <span class="hljs-doctag">@since</span> v16.7.0
     * <span class="hljs-doctag">@experimental</span>
     * <span class="hljs-doctag">@param</span> id A `&#x27;blob:nodedata:...` URL string returned by a prior call to `URL.createObjectURL()`.
     */</span>
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveObjectURL</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Blob</span> | <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">export</span> { <span class="hljs-title class_">Buffer</span> };
    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@experimental</span>
     */</span>
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> BlobOptions {
        <span class="hljs-comment">/**
         * <span class="hljs-doctag">@default</span> &#x27;utf8&#x27;
         */</span>
        encoding?: <span class="hljs-title class_">BufferEncoding</span> | <span class="hljs-literal">undefined</span>;
        <span class="hljs-comment">/**
         * The Blob content-type. The intent is for `type` to convey
         * the MIME media type of the data, however no validation of the type format
         * is performed.
         */</span>
        <span class="hljs-keyword">type</span>?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;
    }
    <span class="hljs-comment">/**
     * A [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) encapsulates immutable, raw data that can be safely shared across
     * multiple worker threads.
     * <span class="hljs-doctag">@since</span> v15.7.0
     * <span class="hljs-doctag">@experimental</span>
     */</span>
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blob</span> {
        <span class="hljs-comment">/**
         * The total size of the `Blob` in bytes.
         * <span class="hljs-doctag">@since</span> v15.7.0
         */</span>
        <span class="hljs-keyword">readonly</span> <span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>;
        <span class="hljs-comment">/**
         * The content-type of the `Blob`.
         * <span class="hljs-doctag">@since</span> v15.7.0
         */</span>
        <span class="hljs-keyword">readonly</span> <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>;
        <span class="hljs-comment">/**
         * Creates a new `Blob` object containing a concatenation of the given sources.
         *
         * {ArrayBuffer}, {TypedArray}, {DataView}, and {Buffer} sources are copied into
         * the &#x27;Blob&#x27; and can therefore be safely modified after the &#x27;Blob&#x27; is created.
         *
         * String sources are also copied into the `Blob`.
         */</span>
        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">sources: <span class="hljs-built_in">Array</span>&lt;BinaryLike | Blob&gt;, options?: BlobOptions</span>);
        <span class="hljs-comment">/**
         * Returns a promise that fulfills with an [&amp;lt;ArrayBuffer&amp;gt;](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) containing a copy of
         * the `Blob` data.
         * <span class="hljs-doctag">@since</span> v15.7.0
         */</span>
        <span class="hljs-title function_">arrayBuffer</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ArrayBuffer</span>&gt;;
        <span class="hljs-comment">/**
         * Creates and returns a new `Blob` containing a subset of this `Blob` objects
         * data. The original `Blob` is not altered.
         * <span class="hljs-doctag">@since</span> v15.7.0
         * <span class="hljs-doctag">@param</span> start The starting index.
         * <span class="hljs-doctag">@param</span> end The ending index.
         * <span class="hljs-doctag">@param</span> type The content-type for the new `Blob`
         */</span>
        <span class="hljs-title function_">slice</span>(start?: <span class="hljs-built_in">number</span>, end?: <span class="hljs-built_in">number</span>, <span class="hljs-keyword">type</span>?: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Blob</span>;
        <span class="hljs-comment">/**
         * Returns a promise that fulfills with the contents of the `Blob` decoded as a
         * UTF-8 string.
         * <span class="hljs-doctag">@since</span> v15.7.0
         */</span>
        <span class="hljs-title function_">text</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;;
        <span class="hljs-comment">/**
         * Returns a new `ReadableStream` that allows the content of the `Blob` to be read.
         * <span class="hljs-doctag">@since</span> v16.7.0
         */</span>
        <span class="hljs-title function_">stream</span>(): unknown; <span class="hljs-comment">// pending web streams types</span>
    }
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> atob = globalThis.<span class="hljs-property">atob</span>;
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> btoa = globalThis.<span class="hljs-property">btoa</span>;
    <span class="hljs-variable language_">global</span> {
        <span class="hljs-comment">// Buffer class</span>
        <span class="hljs-keyword">type</span> <span class="hljs-title class_">BufferEncoding</span> = <span class="hljs-string">&#x27;ascii&#x27;</span> | <span class="hljs-string">&#x27;utf8&#x27;</span> | <span class="hljs-string">&#x27;utf-8&#x27;</span> | <span class="hljs-string">&#x27;utf16le&#x27;</span> | <span class="hljs-string">&#x27;ucs2&#x27;</span> | <span class="hljs-string">&#x27;ucs-2&#x27;</span> | <span class="hljs-string">&#x27;base64&#x27;</span> | <span class="hljs-string">&#x27;base64url&#x27;</span> | <span class="hljs-string">&#x27;latin1&#x27;</span> | <span class="hljs-string">&#x27;binary&#x27;</span> | <span class="hljs-string">&#x27;hex&#x27;</span>;
        <span class="hljs-keyword">type</span> <span class="hljs-title class_">WithImplicitCoercion</span>&lt;T&gt; =
            | T
            | {
                  <span class="hljs-title function_">valueOf</span>(): T;
              };
        <span class="hljs-comment">/**
         * Raw data is stored in instances of the Buffer class.
         * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.
         * Valid string encodings: &#x27;ascii&#x27;|&#x27;utf8&#x27;|&#x27;utf16le&#x27;|&#x27;ucs2&#x27;(alias of &#x27;utf16le&#x27;)|&#x27;base64&#x27;|&#x27;binary&#x27;(deprecated)|&#x27;hex&#x27;
         */</span>
        <span class="hljs-keyword">interface</span> BufferConstructor {
            <span class="hljs-comment">/**
             * Allocates a new buffer containing the given {str}.
             *
             * <span class="hljs-doctag">@param</span> str String to store in buffer.
             * <span class="hljs-doctag">@param</span> encoding encoding to use, optional.  Default is &#x27;utf8&#x27;
             * <span class="hljs-doctag">@deprecated</span> since v10.0.0 - Use `Buffer.from(string[, encoding])` instead.
             */</span>
            <span class="hljs-keyword">new</span> (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>, encoding?: <span class="hljs-title class_">BufferEncoding</span>): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Allocates a new buffer of {size} octets.
             *
             * <span class="hljs-doctag">@param</span> size count of octets to allocate.
             * <span class="hljs-doctag">@deprecated</span> since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).
             */</span>
            <span class="hljs-keyword">new</span> (<span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Allocates a new buffer containing the given {array} of octets.
             *
             * <span class="hljs-doctag">@param</span> array The octets to store.
             * <span class="hljs-doctag">@deprecated</span> since v10.0.0 - Use `Buffer.from(array)` instead.
             */</span>
            <span class="hljs-keyword">new</span> (<span class="hljs-attr">array</span>: <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Produces a Buffer backed by the same allocated memory as
             * the given {ArrayBuffer}/{SharedArrayBuffer}.
             *
             *
             * <span class="hljs-doctag">@param</span> arrayBuffer The ArrayBuffer with which to share memory.
             * <span class="hljs-doctag">@deprecated</span> since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead.
             */</span>
            <span class="hljs-keyword">new</span> (<span class="hljs-attr">arrayBuffer</span>: <span class="hljs-title class_">ArrayBuffer</span> | <span class="hljs-title class_">SharedArrayBuffer</span>): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Allocates a new buffer containing the given {array} of octets.
             *
             * <span class="hljs-doctag">@param</span> array The octets to store.
             * <span class="hljs-doctag">@deprecated</span> since v10.0.0 - Use `Buffer.from(array)` instead.
             */</span>
            <span class="hljs-keyword">new</span> (<span class="hljs-attr">array</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">any</span>&gt;): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Copies the passed {buffer} data onto a new {Buffer} instance.
             *
             * <span class="hljs-doctag">@param</span> buffer The buffer to copy.
             * <span class="hljs-doctag">@deprecated</span> since v10.0.0 - Use `Buffer.from(buffer)` instead.
             */</span>
            <span class="hljs-keyword">new</span> (<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">Buffer</span>): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Allocates a new `Buffer` using an `array` of bytes in the range `0` – `255`.
             * Array entries outside that range will be truncated to fit into it.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * // Creates a new Buffer containing the UTF-8 bytes of the string &#x27;buffer&#x27;.
             * const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);
             * ```
             *
             * A `TypeError` will be thrown if `array` is not an `Array` or another type
             * appropriate for `Buffer.from()` variants.
             *
             * `Buffer.from(array)` and `Buffer.from(string)` may also use the internal`Buffer` pool like `Buffer.allocUnsafe()` does.
             * <span class="hljs-doctag">@since</span> v5.10.0
             */</span>
            <span class="hljs-title function_">from</span>(<span class="hljs-attr">arrayBuffer</span>: <span class="hljs-title class_">WithImplicitCoercion</span>&lt;<span class="hljs-title class_">ArrayBuffer</span> | <span class="hljs-title class_">SharedArrayBuffer</span>&gt;, byteOffset?: <span class="hljs-built_in">number</span>, length?: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Creates a new Buffer using the passed {data}
             * <span class="hljs-doctag">@param</span> data data to create a new Buffer
             */</span>
            <span class="hljs-title function_">from</span>(<span class="hljs-attr">data</span>: <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span> | <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">number</span>&gt;): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-title function_">from</span>(<span class="hljs-attr">data</span>: <span class="hljs-title class_">WithImplicitCoercion</span>&lt;<span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span> | <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">number</span>&gt; | <span class="hljs-built_in">string</span>&gt;): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Creates a new Buffer containing the given JavaScript string {str}.
             * If provided, the {encoding} parameter identifies the character encoding.
             * If not provided, {encoding} defaults to &#x27;utf8&#x27;.
             */</span>
            <span class="hljs-title function_">from</span>(
                <span class="hljs-attr">str</span>:
                    | <span class="hljs-title class_">WithImplicitCoercion</span>&lt;<span class="hljs-built_in">string</span>&gt;
                    | {
                          [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>](<span class="hljs-attr">hint</span>: <span class="hljs-string">&#x27;string&#x27;</span>): <span class="hljs-built_in">string</span>;
                      },
                encoding?: <span class="hljs-title class_">BufferEncoding</span>
            ): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Creates a new Buffer using the passed {data}
             * <span class="hljs-doctag">@param</span> values to create a new Buffer
             */</span>
            <span class="hljs-title function_">of</span>(...<span class="hljs-attr">items</span>: <span class="hljs-built_in">number</span>[]): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Returns `true` if `obj` is a `Buffer`, `false` otherwise.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * Buffer.isBuffer(Buffer.alloc(10)); // true
             * Buffer.isBuffer(Buffer.from(&#x27;foo&#x27;)); // true
             * Buffer.isBuffer(&#x27;a string&#x27;); // false
             * Buffer.isBuffer([]); // false
             * Buffer.isBuffer(new Uint8Array(1024)); // false
             * ```
             * <span class="hljs-doctag">@since</span> v0.1.101
             */</span>
            <span class="hljs-title function_">isBuffer</span>(<span class="hljs-attr">obj</span>: <span class="hljs-built_in">any</span>): obj is <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Returns `true` if `encoding` is the name of a supported character encoding,
             * or `false` otherwise.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * console.log(Buffer.isEncoding(&#x27;utf8&#x27;));
             * // Prints: true
             *
             * console.log(Buffer.isEncoding(&#x27;hex&#x27;));
             * // Prints: true
             *
             * console.log(Buffer.isEncoding(&#x27;utf/8&#x27;));
             * // Prints: false
             *
             * console.log(Buffer.isEncoding(&#x27;&#x27;));
             * // Prints: false
             * ```
             * <span class="hljs-doctag">@since</span> v0.9.1
             * <span class="hljs-doctag">@param</span> encoding A character encoding name to check.
             */</span>
            <span class="hljs-title function_">isEncoding</span>(<span class="hljs-attr">encoding</span>: <span class="hljs-built_in">string</span>): encoding is <span class="hljs-title class_">BufferEncoding</span>;
            <span class="hljs-comment">/**
             * Returns the byte length of a string when encoded using `encoding`.
             * This is not the same as [`String.prototype.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length), which does not account
             * for the encoding that is used to convert the string into bytes.
             *
             * For `&#x27;base64&#x27;`, `&#x27;base64url&#x27;`, and `&#x27;hex&#x27;`, this function assumes valid input.
             * For strings that contain non-base64/hex-encoded data (e.g. whitespace), the
             * return value might be greater than the length of a `Buffer` created from the
             * string.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const str = &#x27;\u00bd + \u00bc = \u00be&#x27;;
             *
             * console.log(`${str}: ${str.length} characters, ` +
             *             `${Buffer.byteLength(str, &#x27;utf8&#x27;)} bytes`);
             * // Prints: ½ + ¼ = ¾: 9 characters, 12 bytes
             * ```
             *
             * When `string` is a
             * `Buffer`/[`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)/[`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/-
             * Reference/Global_Objects/TypedArray)/[`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)/[`SharedArrayBuffer`](https://develop-
             * er.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer), the byte length as reported by `.byteLength`is returned.
             * <span class="hljs-doctag">@since</span> v0.1.90
             * <span class="hljs-doctag">@param</span> string A value to calculate the length of.
             * <span class="hljs-doctag">@param</span> [encoding=&#x27;utf8&#x27;] If `string` is a string, this is its encoding.
             * <span class="hljs-doctag">@return</span> The number of bytes contained within `string`.
             */</span>
            <span class="hljs-title function_">byteLength</span>(<span class="hljs-attr">string</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">Node</span>JS.<span class="hljs-property">ArrayBufferView</span> | <span class="hljs-title class_">ArrayBuffer</span> | <span class="hljs-title class_">SharedArrayBuffer</span>, encoding?: <span class="hljs-title class_">BufferEncoding</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Returns a new `Buffer` which is the result of concatenating all the `Buffer`instances in the `list` together.
             *
             * If the list has no items, or if the `totalLength` is 0, then a new zero-length`Buffer` is returned.
             *
             * If `totalLength` is not provided, it is calculated from the `Buffer` instances
             * in `list` by adding their lengths.
             *
             * If `totalLength` is provided, it is coerced to an unsigned integer. If the
             * combined length of the `Buffer`s in `list` exceeds `totalLength`, the result is
             * truncated to `totalLength`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * // Create a single `Buffer` from a list of three `Buffer` instances.
             *
             * const buf1 = Buffer.alloc(10);
             * const buf2 = Buffer.alloc(14);
             * const buf3 = Buffer.alloc(18);
             * const totalLength = buf1.length + buf2.length + buf3.length;
             *
             * console.log(totalLength);
             * // Prints: 42
             *
             * const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);
             *
             * console.log(bufA);
             * // Prints: &lt;Buffer 00 00 00 00 ...&gt;
             * console.log(bufA.length);
             * // Prints: 42
             * ```
             *
             * `Buffer.concat()` may also use the internal `Buffer` pool like `Buffer.allocUnsafe()` does.
             * <span class="hljs-doctag">@since</span> v0.7.11
             * <span class="hljs-doctag">@param</span> list List of `Buffer` or {<span class="hljs-doctag">@link</span> Uint8Array} instances to concatenate.
             * <span class="hljs-doctag">@param</span> totalLength Total length of the `Buffer` instances in `list` when concatenated.
             */</span>
            <span class="hljs-title function_">concat</span>(<span class="hljs-attr">list</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>&gt;, totalLength?: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Compares `buf1` to `buf2`, typically for the purpose of sorting arrays of`Buffer` instances. This is equivalent to calling `buf1.compare(buf2)`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf1 = Buffer.from(&#x27;1234&#x27;);
             * const buf2 = Buffer.from(&#x27;0123&#x27;);
             * const arr = [buf1, buf2];
             *
             * console.log(arr.sort(Buffer.compare));
             * // Prints: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]
             * // (This result is equal to: [buf2, buf1].)
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.13
             * <span class="hljs-doctag">@return</span> Either `-1`, `0`, or `1`, depending on the result of the comparison. See `compare` for details.
             */</span>
            <span class="hljs-title function_">compare</span>(<span class="hljs-attr">buf1</span>: <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>, <span class="hljs-attr">buf2</span>: <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the`Buffer` will be zero-filled.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.alloc(5);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 00 00 00 00 00&gt;
             * ```
             *
             * If `size` is larger than {<span class="hljs-doctag">@link</span> constants.MAX_LENGTH} or smaller than 0, `ERR_INVALID_ARG_VALUE` is thrown.
             *
             * If `fill` is specified, the allocated `Buffer` will be initialized by calling `buf.fill(fill)`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.alloc(5, &#x27;a&#x27;);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 61 61 61 61 61&gt;
             * ```
             *
             * If both `fill` and `encoding` are specified, the allocated `Buffer` will be
             * initialized by calling `buf.fill(fill, encoding)`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.alloc(11, &#x27;aGVsbG8gd29ybGQ=&#x27;, &#x27;base64&#x27;);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;
             * ```
             *
             * Calling `Buffer.alloc()` can be measurably slower than the alternative `Buffer.allocUnsafe()` but ensures that the newly created `Buffer` instance
             * contents will never contain sensitive data from previous allocations, including
             * data that might not have been allocated for `Buffer`s.
             *
             * A `TypeError` will be thrown if `size` is not a number.
             * <span class="hljs-doctag">@since</span> v5.10.0
             * <span class="hljs-doctag">@param</span> size The desired length of the new `Buffer`.
             * <span class="hljs-doctag">@param</span> [fill=0] A value to pre-fill the new `Buffer` with.
             * <span class="hljs-doctag">@param</span> [encoding=&#x27;utf8&#x27;] If `fill` is a string, this is its encoding.
             */</span>
            <span class="hljs-title function_">alloc</span>(<span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>, fill?: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">Buffer</span> | <span class="hljs-built_in">number</span>, encoding?: <span class="hljs-title class_">BufferEncoding</span>): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {<span class="hljs-doctag">@link</span> constants.MAX_LENGTH} or smaller than 0, `ERR_INVALID_ARG_VALUE` is thrown.
             *
             * The underlying memory for `Buffer` instances created in this way is _not_
             * _initialized_. The contents of the newly created `Buffer` are unknown and_may contain sensitive data_. Use `Buffer.alloc()` instead to initialize`Buffer` instances with zeroes.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(10);
             *
             * console.log(buf);
             * // Prints (contents may vary): &lt;Buffer a0 8b 28 3f 01 00 00 00 50 32&gt;
             *
             * buf.fill(0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;
             * ```
             *
             * A `TypeError` will be thrown if `size` is not a number.
             *
             * The `Buffer` module pre-allocates an internal `Buffer` instance of
             * size `Buffer.poolSize` that is used as a pool for the fast allocation of new`Buffer` instances created using `Buffer.allocUnsafe()`,`Buffer.from(array)`, `Buffer.concat()`, and the
             * deprecated`new Buffer(size)` constructor only when `size` is less than or equal
             * to `Buffer.poolSize &gt;&gt; 1` (floor of `Buffer.poolSize` divided by two).
             *
             * Use of this pre-allocated internal memory pool is a key difference between
             * calling `Buffer.alloc(size, fill)` vs. `Buffer.allocUnsafe(size).fill(fill)`.
             * Specifically, `Buffer.alloc(size, fill)` will _never_ use the internal `Buffer`pool, while `Buffer.allocUnsafe(size).fill(fill)`_will_ use the internal`Buffer` pool if `size` is less
             * than or equal to half `Buffer.poolSize`. The
             * difference is subtle but can be important when an application requires the
             * additional performance that `Buffer.allocUnsafe()` provides.
             * <span class="hljs-doctag">@since</span> v5.10.0
             * <span class="hljs-doctag">@param</span> size The desired length of the new `Buffer`.
             */</span>
            <span class="hljs-title function_">allocUnsafe</span>(<span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {<span class="hljs-doctag">@link</span> constants.MAX_LENGTH} or smaller than 0, `ERR_INVALID_ARG_VALUE` is thrown. A zero-length `Buffer` is created
             * if `size` is 0.
             *
             * The underlying memory for `Buffer` instances created in this way is _not_
             * _initialized_. The contents of the newly created `Buffer` are unknown and_may contain sensitive data_. Use `buf.fill(0)` to initialize
             * such `Buffer` instances with zeroes.
             *
             * When using `Buffer.allocUnsafe()` to allocate new `Buffer` instances,
             * allocations under 4 KB are sliced from a single pre-allocated `Buffer`. This
             * allows applications to avoid the garbage collection overhead of creating many
             * individually allocated `Buffer` instances. This approach improves both
             * performance and memory usage by eliminating the need to track and clean up as
             * many individual `ArrayBuffer` objects.
             *
             * However, in the case where a developer may need to retain a small chunk of
             * memory from a pool for an indeterminate amount of time, it may be appropriate
             * to create an un-pooled `Buffer` instance using `Buffer.allocUnsafeSlow()` and
             * then copying out the relevant bits.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * // Need to keep around a few small chunks of memory.
             * const store = [];
             *
             * socket.on(&#x27;readable&#x27;, () =&gt; {
             *   let data;
             *   while (null !== (data = readable.read())) {
             *     // Allocate for retained data.
             *     const sb = Buffer.allocUnsafeSlow(10);
             *
             *     // Copy the data into the new allocation.
             *     data.copy(sb, 0, 0, 10);
             *
             *     store.push(sb);
             *   }
             * });
             * ```
             *
             * A `TypeError` will be thrown if `size` is not a number.
             * <span class="hljs-doctag">@since</span> v5.12.0
             * <span class="hljs-doctag">@param</span> size The desired length of the new `Buffer`.
             */</span>
            <span class="hljs-title function_">allocUnsafeSlow</span>(<span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * This is the size (in bytes) of pre-allocated internal `Buffer` instances used
             * for pooling. This value may be modified.
             * <span class="hljs-doctag">@since</span> v0.11.3
             */</span>
            <span class="hljs-attr">poolSize</span>: <span class="hljs-built_in">number</span>;
        }
        <span class="hljs-keyword">interface</span> Buffer <span class="hljs-keyword">extends</span> Uint8Array {
            <span class="hljs-comment">/**
             * Writes `string` to `buf` at `offset` according to the character encoding in`encoding`. The `length` parameter is the number of bytes to write. If `buf` did
             * not contain enough space to fit the entire string, only part of `string` will be
             * written. However, partially encoded characters will not be written.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.alloc(256);
             *
             * const len = buf.write(&#x27;\u00bd + \u00bc = \u00be&#x27;, 0);
             *
             * console.log(`${len} bytes: ${buf.toString(&#x27;utf8&#x27;, 0, len)}`);
             * // Prints: 12 bytes: ½ + ¼ = ¾
             *
             * const buffer = Buffer.alloc(10);
             *
             * const length = buffer.write(&#x27;abcd&#x27;, 8);
             *
             * console.log(`${length} bytes: ${buffer.toString(&#x27;utf8&#x27;, 8, 10)}`);
             * // Prints: 2 bytes : ab
             * ```
             * <span class="hljs-doctag">@since</span> v0.1.90
             * <span class="hljs-doctag">@param</span> string String to write to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write `string`.
             * <span class="hljs-doctag">@param</span> [length=buf.length - offset] Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`).
             * <span class="hljs-doctag">@param</span> [encoding=&#x27;utf8&#x27;] The character encoding of `string`.
             * <span class="hljs-doctag">@return</span> Number of bytes written.
             */</span>
            <span class="hljs-title function_">write</span>(<span class="hljs-attr">string</span>: <span class="hljs-built_in">string</span>, encoding?: <span class="hljs-title class_">BufferEncoding</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-title function_">write</span>(<span class="hljs-attr">string</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">offset</span>: <span class="hljs-built_in">number</span>, encoding?: <span class="hljs-title class_">BufferEncoding</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-title function_">write</span>(<span class="hljs-attr">string</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">offset</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>, encoding?: <span class="hljs-title class_">BufferEncoding</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Decodes `buf` to a string according to the specified character encoding in`encoding`. `start` and `end` may be passed to decode only a subset of `buf`.
             *
             * If `encoding` is `&#x27;utf8&#x27;` and a byte sequence in the input is not valid UTF-8,
             * then each invalid byte is replaced with the replacement character `U+FFFD`.
             *
             * The maximum length of a string instance (in UTF-16 code units) is available
             * as {<span class="hljs-doctag">@link</span> constants.MAX_STRING_LENGTH}.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf1 = Buffer.allocUnsafe(26);
             *
             * for (let i = 0; i &lt; 26; i++) {
             *   // 97 is the decimal ASCII value for &#x27;a&#x27;.
             *   buf1[i] = i + 97;
             * }
             *
             * console.log(buf1.toString(&#x27;utf8&#x27;));
             * // Prints: abcdefghijklmnopqrstuvwxyz
             * console.log(buf1.toString(&#x27;utf8&#x27;, 0, 5));
             * // Prints: abcde
             *
             * const buf2 = Buffer.from(&#x27;tést&#x27;);
             *
             * console.log(buf2.toString(&#x27;hex&#x27;));
             * // Prints: 74c3a97374
             * console.log(buf2.toString(&#x27;utf8&#x27;, 0, 3));
             * // Prints: té
             * console.log(buf2.toString(undefined, 0, 3));
             * // Prints: té
             * ```
             * <span class="hljs-doctag">@since</span> v0.1.90
             * <span class="hljs-doctag">@param</span> [encoding=&#x27;utf8&#x27;] The character encoding to use.
             * <span class="hljs-doctag">@param</span> [start=0] The byte offset to start decoding at.
             * <span class="hljs-doctag">@param</span> [end=buf.length] The byte offset to stop decoding at (not inclusive).
             */</span>
            <span class="hljs-title function_"><span id="lsif3091">toString</span></span>(encoding?: <span class="hljs-title class_">BufferEncoding</span>, start?: <span class="hljs-built_in">number</span>, end?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;
            <span class="hljs-comment">/**
             * Returns a JSON representation of `buf`. [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) implicitly calls
             * this function when stringifying a `Buffer` instance.
             *
             * `Buffer.from()` accepts objects in the format returned from this method.
             * In particular, `Buffer.from(buf.toJSON())` works like `Buffer.from(buf)`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
             * const json = JSON.stringify(buf);
             *
             * console.log(json);
             * // Prints: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}
             *
             * const copy = JSON.parse(json, (key, value) =&gt; {
             *   return value &amp;#x26;&amp;#x26; value.type === &#x27;Buffer&#x27; ?
             *     Buffer.from(value) :
             *     value;
             * });
             *
             * console.log(copy);
             * // Prints: &lt;Buffer 01 02 03 04 05&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.9.2
             */</span>
            <span class="hljs-title function_">toJSON</span>(): {
                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Buffer&#x27;</span>;
                <span class="hljs-attr">data</span>: <span class="hljs-built_in">number</span>[];
            };
            <span class="hljs-comment">/**
             * Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes,`false` otherwise. Equivalent to `buf.compare(otherBuffer) === 0`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf1 = Buffer.from(&#x27;ABC&#x27;);
             * const buf2 = Buffer.from(&#x27;414243&#x27;, &#x27;hex&#x27;);
             * const buf3 = Buffer.from(&#x27;ABCD&#x27;);
             *
             * console.log(buf1.equals(buf2));
             * // Prints: true
             * console.log(buf1.equals(buf3));
             * // Prints: false
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.13
             * <span class="hljs-doctag">@param</span> otherBuffer A `Buffer` or {<span class="hljs-doctag">@link</span> Uint8Array} with which to compare `buf`.
             */</span>
            <span class="hljs-title function_">equals</span>(<span class="hljs-attr">otherBuffer</span>: <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>): <span class="hljs-built_in">boolean</span>;
            <span class="hljs-comment">/**
             * Compares `buf` with `target` and returns a number indicating whether `buf`comes before, after, or is the same as `target` in sort order.
             * Comparison is based on the actual sequence of bytes in each `Buffer`.
             *
             * * `0` is returned if `target` is the same as `buf`
             * * `1` is returned if `target` should come _before_`buf` when sorted.
             * * `-1` is returned if `target` should come _after_`buf` when sorted.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf1 = Buffer.from(&#x27;ABC&#x27;);
             * const buf2 = Buffer.from(&#x27;BCD&#x27;);
             * const buf3 = Buffer.from(&#x27;ABCD&#x27;);
             *
             * console.log(buf1.compare(buf1));
             * // Prints: 0
             * console.log(buf1.compare(buf2));
             * // Prints: -1
             * console.log(buf1.compare(buf3));
             * // Prints: -1
             * console.log(buf2.compare(buf1));
             * // Prints: 1
             * console.log(buf2.compare(buf3));
             * // Prints: 1
             * console.log([buf1, buf2, buf3].sort(Buffer.compare));
             * // Prints: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]
             * // (This result is equal to: [buf1, buf3, buf2].)
             * ```
             *
             * The optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd`arguments can be used to limit the comparison to specific ranges within `target`and `buf` respectively.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
             * const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);
             *
             * console.log(buf1.compare(buf2, 5, 9, 0, 4));
             * // Prints: 0
             * console.log(buf1.compare(buf2, 0, 6, 4));
             * // Prints: -1
             * console.log(buf1.compare(buf2, 5, 6, 5));
             * // Prints: 1
             * ```
             *
             * `ERR_OUT_OF_RANGE` is thrown if `targetStart &lt; 0`, `sourceStart &lt; 0`,`targetEnd &gt; target.byteLength`, or `sourceEnd &gt; source.byteLength`.
             * <span class="hljs-doctag">@since</span> v0.11.13
             * <span class="hljs-doctag">@param</span> target A `Buffer` or {<span class="hljs-doctag">@link</span> Uint8Array} with which to compare `buf`.
             * <span class="hljs-doctag">@param</span> [targetStart=0] The offset within `target` at which to begin comparison.
             * <span class="hljs-doctag">@param</span> [targetEnd=target.length] The offset within `target` at which to end comparison (not inclusive).
             * <span class="hljs-doctag">@param</span> [sourceStart=0] The offset within `buf` at which to begin comparison.
             * <span class="hljs-doctag">@param</span> [sourceEnd=buf.length] The offset within `buf` at which to end comparison (not inclusive).
             */</span>
            <span class="hljs-title function_">compare</span>(<span class="hljs-attr">target</span>: <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>, targetStart?: <span class="hljs-built_in">number</span>, targetEnd?: <span class="hljs-built_in">number</span>, sourceStart?: <span class="hljs-built_in">number</span>, sourceEnd?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Copies data from a region of `buf` to a region in `target`, even if the `target`memory region overlaps with `buf`.
             *
             * [`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) performs the same operation, and is available
             * for all TypedArrays, including Node.js `Buffer`s, although it takes
             * different function arguments.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * // Create two `Buffer` instances.
             * const buf1 = Buffer.allocUnsafe(26);
             * const buf2 = Buffer.allocUnsafe(26).fill(&#x27;!&#x27;);
             *
             * for (let i = 0; i &lt; 26; i++) {
             *   // 97 is the decimal ASCII value for &#x27;a&#x27;.
             *   buf1[i] = i + 97;
             * }
             *
             * // Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.
             * buf1.copy(buf2, 8, 16, 20);
             * // This is equivalent to:
             * // buf2.set(buf1.subarray(16, 20), 8);
             *
             * console.log(buf2.toString(&#x27;ascii&#x27;, 0, 25));
             * // Prints: !!!!!!!!qrst!!!!!!!!!!!!!
             * ```
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * // Create a `Buffer` and copy data from one region to an overlapping region
             * // within the same `Buffer`.
             *
             * const buf = Buffer.allocUnsafe(26);
             *
             * for (let i = 0; i &lt; 26; i++) {
             *   // 97 is the decimal ASCII value for &#x27;a&#x27;.
             *   buf[i] = i + 97;
             * }
             *
             * buf.copy(buf, 0, 4, 10);
             *
             * console.log(buf.toString());
             * // Prints: efghijghijklmnopqrstuvwxyz
             * ```
             * <span class="hljs-doctag">@since</span> v0.1.90
             * <span class="hljs-doctag">@param</span> target A `Buffer` or {<span class="hljs-doctag">@link</span> Uint8Array} to copy into.
             * <span class="hljs-doctag">@param</span> [targetStart=0] The offset within `target` at which to begin writing.
             * <span class="hljs-doctag">@param</span> [sourceStart=0] The offset within `buf` from which to begin copying.
             * <span class="hljs-doctag">@param</span> [sourceEnd=buf.length] The offset within `buf` at which to stop copying (not inclusive).
             * <span class="hljs-doctag">@return</span> The number of bytes copied.
             */</span>
            <span class="hljs-title function_">copy</span>(<span class="hljs-attr">target</span>: <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>, targetStart?: <span class="hljs-built_in">number</span>, sourceStart?: <span class="hljs-built_in">number</span>, sourceEnd?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Returns a new `Buffer` that references the same memory as the original, but
             * offset and cropped by the `start` and `end` indices.
             *
             * This is the same behavior as `buf.subarray()`.
             *
             * This method is not compatible with the `Uint8Array.prototype.slice()`,
             * which is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from(&#x27;buffer&#x27;);
             *
             * const copiedBuf = Uint8Array.prototype.slice.call(buf);
             * copiedBuf[0]++;
             * console.log(copiedBuf.toString());
             * // Prints: cuffer
             *
             * console.log(buf.toString());
             * // Prints: buffer
             * ```
             * <span class="hljs-doctag">@since</span> v0.3.0
             * <span class="hljs-doctag">@param</span> [start=0] Where the new `Buffer` will start.
             * <span class="hljs-doctag">@param</span> [end=buf.length] Where the new `Buffer` will end (not inclusive).
             */</span>
            <span class="hljs-title function_">slice</span>(start?: <span class="hljs-built_in">number</span>, end?: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Returns a new `Buffer` that references the same memory as the original, but
             * offset and cropped by the `start` and `end` indices.
             *
             * Specifying `end` greater than `buf.length` will return the same result as
             * that of `end` equal to `buf.length`.
             *
             * This method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).
             *
             * Modifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * // Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte
             * // from the original `Buffer`.
             *
             * const buf1 = Buffer.allocUnsafe(26);
             *
             * for (let i = 0; i &lt; 26; i++) {
             *   // 97 is the decimal ASCII value for &#x27;a&#x27;.
             *   buf1[i] = i + 97;
             * }
             *
             * const buf2 = buf1.subarray(0, 3);
             *
             * console.log(buf2.toString(&#x27;ascii&#x27;, 0, buf2.length));
             * // Prints: abc
             *
             * buf1[0] = 33;
             *
             * console.log(buf2.toString(&#x27;ascii&#x27;, 0, buf2.length));
             * // Prints: !bc
             * ```
             *
             * Specifying negative indexes causes the slice to be generated relative to the
             * end of `buf` rather than the beginning.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from(&#x27;buffer&#x27;);
             *
             * console.log(buf.subarray(-6, -1).toString());
             * // Prints: buffe
             * // (Equivalent to buf.subarray(0, 5).)
             *
             * console.log(buf.subarray(-6, -2).toString());
             * // Prints: buff
             * // (Equivalent to buf.subarray(0, 4).)
             *
             * console.log(buf.subarray(-5, -2).toString());
             * // Prints: uff
             * // (Equivalent to buf.subarray(1, 4).)
             * ```
             * <span class="hljs-doctag">@since</span> v3.0.0
             * <span class="hljs-doctag">@param</span> [start=0] Where the new `Buffer` will start.
             * <span class="hljs-doctag">@param</span> [end=buf.length] Where the new `Buffer` will end (not inclusive).
             */</span>
            <span class="hljs-title function_">subarray</span>(start?: <span class="hljs-built_in">number</span>, end?: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as big-endian.
             *
             * `value` is interpreted and written as a two&#x27;s complement signed integer.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigInt64BE(0x0102030405060708n, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v12.0.0, v10.20.0
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeBigInt64BE</span>(<span class="hljs-attr">value</span>: bigint, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as little-endian.
             *
             * `value` is interpreted and written as a two&#x27;s complement signed integer.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigInt64LE(0x0102030405060708n, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 08 07 06 05 04 03 02 01&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v12.0.0, v10.20.0
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeBigInt64LE</span>(<span class="hljs-attr">value</span>: bigint, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as big-endian.
             *
             * This function is also available under the `writeBigUint64BE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigUInt64BE(0xdecafafecacefaden, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer de ca fa fe ca ce fa de&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v12.0.0, v10.20.0
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeBigUInt64BE</span>(<span class="hljs-attr">value</span>: bigint, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as little-endian
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigUInt64LE(0xdecafafecacefaden, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer de fa ce ca fe fa ca de&gt;
             * ```
             *
             * This function is also available under the `writeBigUint64LE` alias.
             * <span class="hljs-doctag">@since</span> v12.0.0, v10.20.0
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeBigUInt64LE</span>(<span class="hljs-attr">value</span>: bigint, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined
             * when `value` is anything other than an unsigned integer.
             *
             * This function is also available under the `writeUintLE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeUIntLE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer ab 90 78 56 34 12&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> offset Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.
             * <span class="hljs-doctag">@param</span> byteLength Number of bytes to write. Must satisfy `0 &lt; byteLength &lt;= 6`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeUIntLE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">offset</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">byteLength</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined
             * when `value` is anything other than an unsigned integer.
             *
             * This function is also available under the `writeUintBE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeUIntBE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 12 34 56 78 90 ab&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> offset Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.
             * <span class="hljs-doctag">@param</span> byteLength Number of bytes to write. Must satisfy `0 &lt; byteLength &lt;= 6`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeUIntBE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">offset</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">byteLength</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined
             * when `value` is anything other than a signed integer.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeIntLE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer ab 90 78 56 34 12&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> offset Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.
             * <span class="hljs-doctag">@param</span> byteLength Number of bytes to write. Must satisfy `0 &lt; byteLength &lt;= 6`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeIntLE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">offset</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">byteLength</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when`value` is anything other than a
             * signed integer.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeIntBE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 12 34 56 78 90 ab&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> offset Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.
             * <span class="hljs-doctag">@param</span> byteLength Number of bytes to write. Must satisfy `0 &lt; byteLength &lt;= 6`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeIntBE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">offset</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">byteLength</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads an unsigned, big-endian 64-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readBigUint64BE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
             *
             * console.log(buf.readBigUInt64BE(0));
             * // Prints: 4294967295n
             * ```
             * <span class="hljs-doctag">@since</span> v12.0.0, v10.20.0
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.
             */</span>
            <span class="hljs-title function_">readBigUInt64BE</span>(offset?: <span class="hljs-built_in">number</span>): bigint;
            <span class="hljs-comment">/**
             * Reads an unsigned, little-endian 64-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readBigUint64LE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
             *
             * console.log(buf.readBigUInt64LE(0));
             * // Prints: 18446744069414584320n
             * ```
             * <span class="hljs-doctag">@since</span> v12.0.0, v10.20.0
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.
             */</span>
            <span class="hljs-title function_">readBigUInt64LE</span>(offset?: <span class="hljs-built_in">number</span>): bigint;
            <span class="hljs-comment">/**
             * Reads a signed, big-endian 64-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two&#x27;s complement signed
             * values.
             * <span class="hljs-doctag">@since</span> v12.0.0, v10.20.0
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.
             */</span>
            <span class="hljs-title function_">readBigInt64BE</span>(offset?: <span class="hljs-built_in">number</span>): bigint;
            <span class="hljs-comment">/**
             * Reads a signed, little-endian 64-bit integer from `buf` at the specified`offset`.
             *
             * Integers read from a `Buffer` are interpreted as two&#x27;s complement signed
             * values.
             * <span class="hljs-doctag">@since</span> v12.0.0, v10.20.0
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.
             */</span>
            <span class="hljs-title function_">readBigInt64LE</span>(offset?: <span class="hljs-built_in">number</span>): bigint;
            <span class="hljs-comment">/**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as an unsigned, little-endian integer supporting
             * up to 48 bits of accuracy.
             *
             * This function is also available under the `readUintLE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readUIntLE(0, 6).toString(16));
             * // Prints: ab9078563412
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> offset Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.
             * <span class="hljs-doctag">@param</span> byteLength Number of bytes to read. Must satisfy `0 &lt; byteLength &lt;= 6`.
             */</span>
            <span class="hljs-title function_">readUIntLE</span>(<span class="hljs-attr">offset</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">byteLength</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as an unsigned big-endian integer supporting
             * up to 48 bits of accuracy.
             *
             * This function is also available under the `readUintBE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readUIntBE(0, 6).toString(16));
             * // Prints: 1234567890ab
             * console.log(buf.readUIntBE(1, 6).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> offset Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.
             * <span class="hljs-doctag">@param</span> byteLength Number of bytes to read. Must satisfy `0 &lt; byteLength &lt;= 6`.
             */</span>
            <span class="hljs-title function_">readUIntBE</span>(<span class="hljs-attr">offset</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">byteLength</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as a little-endian, two&#x27;s complement signed value
             * supporting up to 48 bits of accuracy.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readIntLE(0, 6).toString(16));
             * // Prints: -546f87a9cbee
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> offset Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.
             * <span class="hljs-doctag">@param</span> byteLength Number of bytes to read. Must satisfy `0 &lt; byteLength &lt;= 6`.
             */</span>
            <span class="hljs-title function_">readIntLE</span>(<span class="hljs-attr">offset</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">byteLength</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as a big-endian, two&#x27;s complement signed value
             * supporting up to 48 bits of accuracy.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readIntBE(0, 6).toString(16));
             * // Prints: 1234567890ab
             * console.log(buf.readIntBE(1, 6).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * console.log(buf.readIntBE(1, 0).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> offset Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.
             * <span class="hljs-doctag">@param</span> byteLength Number of bytes to read. Must satisfy `0 &lt; byteLength &lt;= 6`.
             */</span>
            <span class="hljs-title function_">readIntBE</span>(<span class="hljs-attr">offset</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">byteLength</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads an unsigned 8-bit integer from `buf` at the specified `offset`.
             *
             * This function is also available under the `readUint8` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([1, -2]);
             *
             * console.log(buf.readUInt8(0));
             * // Prints: 1
             * console.log(buf.readUInt8(1));
             * // Prints: 254
             * console.log(buf.readUInt8(2));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.0
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 1`.
             */</span>
            <span class="hljs-title function_">readUInt8</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads an unsigned, little-endian 16-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint16LE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56]);
             *
             * console.log(buf.readUInt16LE(0).toString(16));
             * // Prints: 3412
             * console.log(buf.readUInt16LE(1).toString(16));
             * // Prints: 5634
             * console.log(buf.readUInt16LE(2).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.
             */</span>
            <span class="hljs-title function_">readUInt16LE</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads an unsigned, big-endian 16-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint16BE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56]);
             *
             * console.log(buf.readUInt16BE(0).toString(16));
             * // Prints: 1234
             * console.log(buf.readUInt16BE(1).toString(16));
             * // Prints: 3456
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.
             */</span>
            <span class="hljs-title function_">readUInt16BE</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads an unsigned, little-endian 32-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint32LE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);
             *
             * console.log(buf.readUInt32LE(0).toString(16));
             * // Prints: 78563412
             * console.log(buf.readUInt32LE(1).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.
             */</span>
            <span class="hljs-title function_">readUInt32LE</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads an unsigned, big-endian 32-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint32BE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);
             *
             * console.log(buf.readUInt32BE(0).toString(16));
             * // Prints: 12345678
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.
             */</span>
            <span class="hljs-title function_">readUInt32BE</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads a signed 8-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two&#x27;s complement signed values.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([-1, 5]);
             *
             * console.log(buf.readInt8(0));
             * // Prints: -1
             * console.log(buf.readInt8(1));
             * // Prints: 5
             * console.log(buf.readInt8(2));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.0
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 1`.
             */</span>
            <span class="hljs-title function_">readInt8</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads a signed, little-endian 16-bit integer from `buf` at the specified`offset`.
             *
             * Integers read from a `Buffer` are interpreted as two&#x27;s complement signed values.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0, 5]);
             *
             * console.log(buf.readInt16LE(0));
             * // Prints: 1280
             * console.log(buf.readInt16LE(1));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.
             */</span>
            <span class="hljs-title function_">readInt16LE</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads a signed, big-endian 16-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two&#x27;s complement signed values.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0, 5]);
             *
             * console.log(buf.readInt16BE(0));
             * // Prints: 5
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.
             */</span>
            <span class="hljs-title function_">readInt16BE</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads a signed, little-endian 32-bit integer from `buf` at the specified`offset`.
             *
             * Integers read from a `Buffer` are interpreted as two&#x27;s complement signed values.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0, 0, 0, 5]);
             *
             * console.log(buf.readInt32LE(0));
             * // Prints: 83886080
             * console.log(buf.readInt32LE(1));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.
             */</span>
            <span class="hljs-title function_">readInt32LE</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads a signed, big-endian 32-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two&#x27;s complement signed values.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([0, 0, 0, 5]);
             *
             * console.log(buf.readInt32BE(0));
             * // Prints: 5
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.
             */</span>
            <span class="hljs-title function_">readInt32BE</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads a 32-bit, little-endian float from `buf` at the specified `offset`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([1, 2, 3, 4]);
             *
             * console.log(buf.readFloatLE(0));
             * // Prints: 1.539989614439558e-36
             * console.log(buf.readFloatLE(1));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.
             */</span>
            <span class="hljs-title function_">readFloatLE</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads a 32-bit, big-endian float from `buf` at the specified `offset`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([1, 2, 3, 4]);
             *
             * console.log(buf.readFloatBE(0));
             * // Prints: 2.387939260590663e-38
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.
             */</span>
            <span class="hljs-title function_">readFloatBE</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads a 64-bit, little-endian double from `buf` at the specified `offset`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);
             *
             * console.log(buf.readDoubleLE(0));
             * // Prints: 5.447603722011605e-270
             * console.log(buf.readDoubleLE(1));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 8`.
             */</span>
            <span class="hljs-title function_">readDoubleLE</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Reads a 64-bit, big-endian double from `buf` at the specified `offset`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);
             *
             * console.log(buf.readDoubleBE(0));
             * // Prints: 8.20788039913184e-304
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 8`.
             */</span>
            <span class="hljs-title function_">readDoubleBE</span>(offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-title function_">reverse</span>(): <span class="hljs-variable language_">this</span>;
            <span class="hljs-comment">/**
             * Interprets `buf` as an array of unsigned 16-bit integers and swaps the
             * byte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 2.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
             *
             * console.log(buf1);
             * // Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;
             *
             * buf1.swap16();
             *
             * console.log(buf1);
             * // Prints: &lt;Buffer 02 01 04 03 06 05 08 07&gt;
             *
             * const buf2 = Buffer.from([0x1, 0x2, 0x3]);
             *
             * buf2.swap16();
             * // Throws ERR_INVALID_BUFFER_SIZE.
             * ```
             *
             * One convenient use of `buf.swap16()` is to perform a fast in-place conversion
             * between UTF-16 little-endian and UTF-16 big-endian:
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from(&#x27;This is little-endian UTF-16&#x27;, &#x27;utf16le&#x27;);
             * buf.swap16(); // Convert to big-endian UTF-16 text.
             * ```
             * <span class="hljs-doctag">@since</span> v5.10.0
             * <span class="hljs-doctag">@return</span> A reference to `buf`.
             */</span>
            <span class="hljs-title function_">swap16</span>(): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Interprets `buf` as an array of unsigned 32-bit integers and swaps the
             * byte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 4.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
             *
             * console.log(buf1);
             * // Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;
             *
             * buf1.swap32();
             *
             * console.log(buf1);
             * // Prints: &lt;Buffer 04 03 02 01 08 07 06 05&gt;
             *
             * const buf2 = Buffer.from([0x1, 0x2, 0x3]);
             *
             * buf2.swap32();
             * // Throws ERR_INVALID_BUFFER_SIZE.
             * ```
             * <span class="hljs-doctag">@since</span> v5.10.0
             * <span class="hljs-doctag">@return</span> A reference to `buf`.
             */</span>
            <span class="hljs-title function_">swap32</span>(): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Interprets `buf` as an array of 64-bit numbers and swaps byte order _in-place_.
             * Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
             *
             * console.log(buf1);
             * // Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;
             *
             * buf1.swap64();
             *
             * console.log(buf1);
             * // Prints: &lt;Buffer 08 07 06 05 04 03 02 01&gt;
             *
             * const buf2 = Buffer.from([0x1, 0x2, 0x3]);
             *
             * buf2.swap64();
             * // Throws ERR_INVALID_BUFFER_SIZE.
             * ```
             * <span class="hljs-doctag">@since</span> v6.3.0
             * <span class="hljs-doctag">@return</span> A reference to `buf`.
             */</span>
            <span class="hljs-title function_">swap64</span>(): <span class="hljs-title class_">Buffer</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset`. `value` must be a
             * valid unsigned 8-bit integer. Behavior is undefined when `value` is anything
             * other than an unsigned 8-bit integer.
             *
             * This function is also available under the `writeUint8` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt8(0x3, 0);
             * buf.writeUInt8(0x4, 1);
             * buf.writeUInt8(0x23, 2);
             * buf.writeUInt8(0x42, 3);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 03 04 23 42&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.0
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 1`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeUInt8</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a valid unsigned 16-bit integer. Behavior is undefined when `value` is
             * anything other than an unsigned 16-bit integer.
             *
             * This function is also available under the `writeUint16LE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt16LE(0xdead, 0);
             * buf.writeUInt16LE(0xbeef, 2);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer ad de ef be&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeUInt16LE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a valid unsigned 16-bit integer. Behavior is undefined when `value`is anything other than an
             * unsigned 16-bit integer.
             *
             * This function is also available under the `writeUint16BE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt16BE(0xdead, 0);
             * buf.writeUInt16BE(0xbeef, 2);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer de ad be ef&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeUInt16BE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a valid unsigned 32-bit integer. Behavior is undefined when `value` is
             * anything other than an unsigned 32-bit integer.
             *
             * This function is also available under the `writeUint32LE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt32LE(0xfeedface, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer ce fa ed fe&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeUInt32LE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a valid unsigned 32-bit integer. Behavior is undefined when `value`is anything other than an
             * unsigned 32-bit integer.
             *
             * This function is also available under the `writeUint32BE` alias.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt32BE(0xfeedface, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer fe ed fa ce&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeUInt32BE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset`. `value` must be a valid
             * signed 8-bit integer. Behavior is undefined when `value` is anything other than
             * a signed 8-bit integer.
             *
             * `value` is interpreted and written as a two&#x27;s complement signed integer.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(2);
             *
             * buf.writeInt8(2, 0);
             * buf.writeInt8(-2, 1);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 02 fe&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.0
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 1`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeInt8</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as little-endian.  The `value`must be a valid signed 16-bit integer. Behavior is undefined when `value` is
             * anything other than a signed 16-bit integer.
             *
             * The `value` is interpreted and written as a two&#x27;s complement signed integer.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(2);
             *
             * buf.writeInt16LE(0x0304, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 04 03&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeInt16LE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as big-endian.  The `value`must be a valid signed 16-bit integer. Behavior is undefined when `value` is
             * anything other than a signed 16-bit integer.
             *
             * The `value` is interpreted and written as a two&#x27;s complement signed integer.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(2);
             *
             * buf.writeInt16BE(0x0102, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 01 02&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeInt16BE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a valid signed 32-bit integer. Behavior is undefined when `value` is
             * anything other than a signed 32-bit integer.
             *
             * The `value` is interpreted and written as a two&#x27;s complement signed integer.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeInt32LE(0x05060708, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 08 07 06 05&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeInt32LE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a valid signed 32-bit integer. Behavior is undefined when `value` is
             * anything other than a signed 32-bit integer.
             *
             * The `value` is interpreted and written as a two&#x27;s complement signed integer.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeInt32BE(0x01020304, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 01 02 03 04&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.5
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeInt32BE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as little-endian. Behavior is
             * undefined when `value` is anything other than a JavaScript number.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeFloatLE(0xcafebabe, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer bb fe 4a 4f&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeFloatLE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as big-endian. Behavior is
             * undefined when `value` is anything other than a JavaScript number.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeFloatBE(0xcafebabe, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 4f 4a fe bb&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeFloatBE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a JavaScript number. Behavior is undefined when `value` is anything
             * other than a JavaScript number.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeDoubleLE(123.456, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 77 be 9f 1a 2f dd 5e 40&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 8`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeDoubleLE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a JavaScript number. Behavior is undefined when `value` is anything
             * other than a JavaScript number.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeDoubleBE(123.456, 0);
             *
             * console.log(buf);
             * // Prints: &lt;Buffer 40 5e dd 2f 1a 9f be 77&gt;
             * ```
             * <span class="hljs-doctag">@since</span> v0.11.15
             * <span class="hljs-doctag">@param</span> value Number to be written to `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 8`.
             * <span class="hljs-doctag">@return</span> `offset` plus the number of bytes written.
             */</span>
            <span class="hljs-title function_">writeDoubleBE</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Fills `buf` with the specified `value`. If the `offset` and `end` are not given,
             * the entire `buf` will be filled:
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * // Fill a `Buffer` with the ASCII character &#x27;h&#x27;.
             *
             * const b = Buffer.allocUnsafe(50).fill(&#x27;h&#x27;);
             *
             * console.log(b.toString());
             * // Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
             * ```
             *
             * `value` is coerced to a `uint32` value if it is not a string, `Buffer`, or
             * integer. If the resulting integer is greater than `255` (decimal), `buf` will be
             * filled with `value &amp;#x26; 255`.
             *
             * If the final write of a `fill()` operation falls on a multi-byte character,
             * then only the bytes of that character that fit into `buf` are written:
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * // Fill a `Buffer` with character that takes up two bytes in UTF-8.
             *
             * console.log(Buffer.allocUnsafe(5).fill(&#x27;\u0222&#x27;));
             * // Prints: &lt;Buffer c8 a2 c8 a2 c8&gt;
             * ```
             *
             * If `value` contains invalid characters, it is truncated; if no valid
             * fill data remains, an exception is thrown:
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.allocUnsafe(5);
             *
             * console.log(buf.fill(&#x27;a&#x27;));
             * // Prints: &lt;Buffer 61 61 61 61 61&gt;
             * console.log(buf.fill(&#x27;aazz&#x27;, &#x27;hex&#x27;));
             * // Prints: &lt;Buffer aa aa aa aa aa&gt;
             * console.log(buf.fill(&#x27;zz&#x27;, &#x27;hex&#x27;));
             * // Throws an exception.
             * ```
             * <span class="hljs-doctag">@since</span> v0.5.0
             * <span class="hljs-doctag">@param</span> value The value with which to fill `buf`.
             * <span class="hljs-doctag">@param</span> [offset=0] Number of bytes to skip before starting to fill `buf`.
             * <span class="hljs-doctag">@param</span> [end=buf.length] Where to stop filling `buf` (not inclusive).
             * <span class="hljs-doctag">@param</span> [encoding=&#x27;utf8&#x27;] The encoding for `value` if `value` is a string.
             * <span class="hljs-doctag">@return</span> A reference to `buf`.
             */</span>
            <span class="hljs-title function_">fill</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span> | <span class="hljs-built_in">number</span>, offset?: <span class="hljs-built_in">number</span>, end?: <span class="hljs-built_in">number</span>, encoding?: <span class="hljs-title class_">BufferEncoding</span>): <span class="hljs-variable language_">this</span>;
            <span class="hljs-comment">/**
             * If `value` is:
             *
             * * a string, `value` is interpreted according to the character encoding in`encoding`.
             * * a `Buffer` or [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), `value` will be used in its entirety.
             * To compare a partial `Buffer`, use `buf.slice()`.
             * * a number, `value` will be interpreted as an unsigned 8-bit integer
             * value between `0` and `255`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from(&#x27;this is a buffer&#x27;);
             *
             * console.log(buf.indexOf(&#x27;this&#x27;));
             * // Prints: 0
             * console.log(buf.indexOf(&#x27;is&#x27;));
             * // Prints: 2
             * console.log(buf.indexOf(Buffer.from(&#x27;a buffer&#x27;)));
             * // Prints: 8
             * console.log(buf.indexOf(97));
             * // Prints: 8 (97 is the decimal ASCII value for &#x27;a&#x27;)
             * console.log(buf.indexOf(Buffer.from(&#x27;a buffer example&#x27;)));
             * // Prints: -1
             * console.log(buf.indexOf(Buffer.from(&#x27;a buffer example&#x27;).slice(0, 8)));
             * // Prints: 8
             *
             * const utf16Buffer = Buffer.from(&#x27;\u039a\u0391\u03a3\u03a3\u0395&#x27;, &#x27;utf16le&#x27;);
             *
             * console.log(utf16Buffer.indexOf(&#x27;\u03a3&#x27;, 0, &#x27;utf16le&#x27;));
             * // Prints: 4
             * console.log(utf16Buffer.indexOf(&#x27;\u03a3&#x27;, -4, &#x27;utf16le&#x27;));
             * // Prints: 6
             * ```
             *
             * If `value` is not a string, number, or `Buffer`, this method will throw a`TypeError`. If `value` is a number, it will be coerced to a valid byte value,
             * an integer between 0 and 255.
             *
             * If `byteOffset` is not a number, it will be coerced to a number. If the result
             * of coercion is `NaN` or `0`, then the entire buffer will be searched. This
             * behavior matches [`String.prototype.indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf).
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const b = Buffer.from(&#x27;abcdef&#x27;);
             *
             * // Passing a value that&#x27;s a number, but not a valid byte.
             * // Prints: 2, equivalent to searching for 99 or &#x27;c&#x27;.
             * console.log(b.indexOf(99.9));
             * console.log(b.indexOf(256 + 99));
             *
             * // Passing a byteOffset that coerces to NaN or 0.
             * // Prints: 1, searching the whole buffer.
             * console.log(b.indexOf(&#x27;b&#x27;, undefined));
             * console.log(b.indexOf(&#x27;b&#x27;, {}));
             * console.log(b.indexOf(&#x27;b&#x27;, null));
             * console.log(b.indexOf(&#x27;b&#x27;, []));
             * ```
             *
             * If `value` is an empty string or empty `Buffer` and `byteOffset` is less
             * than `buf.length`, `byteOffset` will be returned. If `value` is empty and`byteOffset` is at least `buf.length`, `buf.length` will be returned.
             * <span class="hljs-doctag">@since</span> v1.5.0
             * <span class="hljs-doctag">@param</span> value What to search for.
             * <span class="hljs-doctag">@param</span> [byteOffset=0] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.
             * <span class="hljs-doctag">@param</span> [encoding=&#x27;utf8&#x27;] If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.
             * <span class="hljs-doctag">@return</span> The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.
             */</span>
            <span class="hljs-title function_">indexOf</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>, byteOffset?: <span class="hljs-built_in">number</span>, encoding?: <span class="hljs-title class_">BufferEncoding</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Identical to `buf.indexOf()`, except the last occurrence of `value` is found
             * rather than the first occurrence.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from(&#x27;this buffer is a buffer&#x27;);
             *
             * console.log(buf.lastIndexOf(&#x27;this&#x27;));
             * // Prints: 0
             * console.log(buf.lastIndexOf(&#x27;buffer&#x27;));
             * // Prints: 17
             * console.log(buf.lastIndexOf(Buffer.from(&#x27;buffer&#x27;)));
             * // Prints: 17
             * console.log(buf.lastIndexOf(97));
             * // Prints: 15 (97 is the decimal ASCII value for &#x27;a&#x27;)
             * console.log(buf.lastIndexOf(Buffer.from(&#x27;yolo&#x27;)));
             * // Prints: -1
             * console.log(buf.lastIndexOf(&#x27;buffer&#x27;, 5));
             * // Prints: 5
             * console.log(buf.lastIndexOf(&#x27;buffer&#x27;, 4));
             * // Prints: -1
             *
             * const utf16Buffer = Buffer.from(&#x27;\u039a\u0391\u03a3\u03a3\u0395&#x27;, &#x27;utf16le&#x27;);
             *
             * console.log(utf16Buffer.lastIndexOf(&#x27;\u03a3&#x27;, undefined, &#x27;utf16le&#x27;));
             * // Prints: 6
             * console.log(utf16Buffer.lastIndexOf(&#x27;\u03a3&#x27;, -5, &#x27;utf16le&#x27;));
             * // Prints: 4
             * ```
             *
             * If `value` is not a string, number, or `Buffer`, this method will throw a`TypeError`. If `value` is a number, it will be coerced to a valid byte value,
             * an integer between 0 and 255.
             *
             * If `byteOffset` is not a number, it will be coerced to a number. Any arguments
             * that coerce to `NaN`, like `{}` or `undefined`, will search the whole buffer.
             * This behavior matches [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf).
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const b = Buffer.from(&#x27;abcdef&#x27;);
             *
             * // Passing a value that&#x27;s a number, but not a valid byte.
             * // Prints: 2, equivalent to searching for 99 or &#x27;c&#x27;.
             * console.log(b.lastIndexOf(99.9));
             * console.log(b.lastIndexOf(256 + 99));
             *
             * // Passing a byteOffset that coerces to NaN.
             * // Prints: 1, searching the whole buffer.
             * console.log(b.lastIndexOf(&#x27;b&#x27;, undefined));
             * console.log(b.lastIndexOf(&#x27;b&#x27;, {}));
             *
             * // Passing a byteOffset that coerces to 0.
             * // Prints: -1, equivalent to passing 0.
             * console.log(b.lastIndexOf(&#x27;b&#x27;, null));
             * console.log(b.lastIndexOf(&#x27;b&#x27;, []));
             * ```
             *
             * If `value` is an empty string or empty `Buffer`, `byteOffset` will be returned.
             * <span class="hljs-doctag">@since</span> v6.0.0
             * <span class="hljs-doctag">@param</span> value What to search for.
             * <span class="hljs-doctag">@param</span> [byteOffset=buf.length - 1] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.
             * <span class="hljs-doctag">@param</span> [encoding=&#x27;utf8&#x27;] If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.
             * <span class="hljs-doctag">@return</span> The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.
             */</span>
            <span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>, byteOffset?: <span class="hljs-built_in">number</span>, encoding?: <span class="hljs-title class_">BufferEncoding</span>): <span class="hljs-built_in">number</span>;
            <span class="hljs-comment">/**
             * Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) of `[index, byte]` pairs from the contents
             * of `buf`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * // Log the entire contents of a `Buffer`.
             *
             * const buf = Buffer.from(&#x27;buffer&#x27;);
             *
             * for (const pair of buf.entries()) {
             *   console.log(pair);
             * }
             * // Prints:
             * //   [0, 98]
             * //   [1, 117]
             * //   [2, 102]
             * //   [3, 102]
             * //   [4, 101]
             * //   [5, 114]
             * ```
             * <span class="hljs-doctag">@since</span> v1.1.0
             */</span>
            <span class="hljs-title function_">entries</span>(): <span class="hljs-title class_">IterableIterator</span>&lt;[<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]&gt;;
            <span class="hljs-comment">/**
             * Equivalent to `buf.indexOf() !== -1`.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from(&#x27;this is a buffer&#x27;);
             *
             * console.log(buf.includes(&#x27;this&#x27;));
             * // Prints: true
             * console.log(buf.includes(&#x27;is&#x27;));
             * // Prints: true
             * console.log(buf.includes(Buffer.from(&#x27;a buffer&#x27;)));
             * // Prints: true
             * console.log(buf.includes(97));
             * // Prints: true (97 is the decimal ASCII value for &#x27;a&#x27;)
             * console.log(buf.includes(Buffer.from(&#x27;a buffer example&#x27;)));
             * // Prints: false
             * console.log(buf.includes(Buffer.from(&#x27;a buffer example&#x27;).slice(0, 8)));
             * // Prints: true
             * console.log(buf.includes(&#x27;this&#x27;, 4));
             * // Prints: false
             * ```
             * <span class="hljs-doctag">@since</span> v5.3.0
             * <span class="hljs-doctag">@param</span> value What to search for.
             * <span class="hljs-doctag">@param</span> [byteOffset=0] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.
             * <span class="hljs-doctag">@param</span> [encoding=&#x27;utf8&#x27;] If `value` is a string, this is its encoding.
             * <span class="hljs-doctag">@return</span> `true` if `value` was found in `buf`, `false` otherwise.
             */</span>
            <span class="hljs-title function_">includes</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-title class_">Buffer</span>, byteOffset?: <span class="hljs-built_in">number</span>, encoding?: <span class="hljs-title class_">BufferEncoding</span>): <span class="hljs-built_in">boolean</span>;
            <span class="hljs-comment">/**
             * Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) of `buf` keys (indices).
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from(&#x27;buffer&#x27;);
             *
             * for (const key of buf.keys()) {
             *   console.log(key);
             * }
             * // Prints:
             * //   0
             * //   1
             * //   2
             * //   3
             * //   4
             * //   5
             * ```
             * <span class="hljs-doctag">@since</span> v1.1.0
             */</span>
            <span class="hljs-title function_">keys</span>(): <span class="hljs-title class_">IterableIterator</span>&lt;<span class="hljs-built_in">number</span>&gt;;
            <span class="hljs-comment">/**
             * Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) for `buf` values (bytes). This function is
             * called automatically when a `Buffer` is used in a `for..of` statement.
             *
             * ```js
             * import { Buffer } from &#x27;buffer&#x27;;
             *
             * const buf = Buffer.from(&#x27;buffer&#x27;);
             *
             * for (const value of buf.values()) {
             *   console.log(value);
             * }
             * // Prints:
             * //   98
             * //   117
             * //   102
             * //   102
             * //   101
             * //   114
             *
             * for (const value of buf) {
             *   console.log(value);
             * }
             * // Prints:
             * //   98
             * //   117
             * //   102
             * //   102
             * //   101
             * //   114
             * ```
             * <span class="hljs-doctag">@since</span> v1.1.0
             */</span>
            <span class="hljs-title function_">values</span>(): <span class="hljs-title class_">IterableIterator</span>&lt;<span class="hljs-built_in">number</span>&gt;;
        }
        <span class="hljs-keyword">var</span> <span class="hljs-title class_">Buffer</span>: <span class="hljs-title class_">BufferConstructor</span>;
        <span class="hljs-comment">/**
         * Decodes a string of Base64-encoded data into bytes, and encodes those bytes
         * into a string using Latin-1 (ISO-8859-1).
         *
         * The `data` may be any JavaScript-value that can be coerced into a string.
         *
         * **This function is only provided for compatibility with legacy web platform APIs**
         * **and should never be used in new code, because they use strings to represent**
         * **binary data and predate the introduction of typed arrays in JavaScript.**
         * **For code running using Node.js APIs, converting between base64-encoded strings**
         * **and binary data should be performed using `Buffer.from(str, &#x27;base64&#x27;)` and`buf.toString(&#x27;base64&#x27;)`.**
         * <span class="hljs-doctag">@since</span> v15.13.0
         * <span class="hljs-doctag">@deprecated</span> Use `Buffer.from(data, &#x27;base64&#x27;)` instead.
         * <span class="hljs-doctag">@param</span> data The Base64-encoded input string.
         */</span>
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">atob</span>(<span class="hljs-params">data: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>;
        <span class="hljs-comment">/**
         * Decodes a string into bytes using Latin-1 (ISO-8859), and encodes those bytes
         * into a string using Base64.
         *
         * The `data` may be any JavaScript-value that can be coerced into a string.
         *
         * **This function is only provided for compatibility with legacy web platform APIs**
         * **and should never be used in new code, because they use strings to represent**
         * **binary data and predate the introduction of typed arrays in JavaScript.**
         * **For code running using Node.js APIs, converting between base64-encoded strings**
         * **and binary data should be performed using `Buffer.from(str, &#x27;base64&#x27;)` and`buf.toString(&#x27;base64&#x27;)`.**
         * <span class="hljs-doctag">@since</span> v15.13.0
         * <span class="hljs-doctag">@deprecated</span> Use `buf.toString(&#x27;base64&#x27;)` instead.
         * <span class="hljs-doctag">@param</span> data An ASCII (Latin1) string.
         */</span>
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">btoa</span>(<span class="hljs-params">data: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>;
    }
}
<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;node:buffer&#x27;</span> {
    <span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;buffer&#x27;</span>;
}
